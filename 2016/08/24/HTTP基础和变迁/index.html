
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HTTP基础和变迁 | yuluo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="HTTP​    HTTP（HyperTextTransferProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP 协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户 信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP基础和变迁">
<meta property="og:url" content="http://www.yuluoding.com/2016/08/24/HTTP基础和变迁/index.html">
<meta property="og:site_name" content="yuluo">
<meta property="og:description" content="HTTP​    HTTP（HyperTextTransferProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP 协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户 信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的">
<meta property="og:image" content="https://ooo.0o0.ooo/2016/08/24/57bd53f7b4ad8.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2016/08/24/57bd53f7bdeba.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2016/08/24/57bd53f7f3f19.jpg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HTTP基础和变迁">
<meta name="twitter:description" content="HTTP​    HTTP（HyperTextTransferProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP 协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户 信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的">
  
    <link rel="alternative" href="/atom.xml" title="yuluo" type="application/atom+xml">
  

  
  	<link rel="icon" type="image/x-icon" href="/favicon.ico">
    <!-- <link rel="icon" href="/favicon.png"> -->
  

  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

<script type="text/javascript">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?09f99e1cd94cce11276e07fa0c1221f6";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</script>

</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">yuluo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">The home of yuluoding!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="www.yuluoding.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-HTTP基础和变迁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/24/HTTP基础和变迁/" class="article-date">
  <time datetime="2016-08-24T06:33:01.000Z" itemprop="datePublished">2016-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HTTP基础和变迁
    </h1>
  

      </header>
    


    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTTP">HTTP</h2><p>​    HTTP（HyperTextTransferProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP 协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户 信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。<br>HTTP是一种无状态性的协议。这是因为此种协议不要求浏览器在每次请求中标明它自己的身份，并且浏览器以及服务器之间并没有保持一个持久性的连接用于多个页面之间的访问。当一个用户访问一个站点的时候，用户的浏览器发送一个HTTP请求到服务器，服务器返回给浏览器一个HTTP响应。其实很简单的一个概念，客户端一个请求，服务器端一个回复，这就是整个基于HTTP协议的通讯过程。</p>
<a id="more"></a>
<h3 id="URL">URL</h3><p>​    在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫URL（Uniform Resource Locator,统一资源定位符），它是WWW的统一资源定位标志。URL分为绝对URL与相对URL两种。绝对URL和访问时的状态完全无关。与之相对应的是省略了部分信息的相对（relative）URL，如../file.php?text=hello+world，它需要根据当前浏览所在上下文环境里的基准URL，才能确定完整的URL地址。</p>
<p>​    URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。URL的一般语法格式为：(带方括号[]的为可选项)：<code>protocol :// hostname[:port] / path / ;parameters#fragment</code></p>
<h3 id="消息格式">消息格式</h3><p>​    通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。HTTP的头域包括<strong>通用头，请求头，响应头和实体头</strong>四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>
<p>​    当用户访问<a href="HTTP://example.com" target="_blank" rel="external">HTTP://example.com</a>这个域名的时候，浏览器就会自动和服务器建立tcp/ip连接，然后发送HTTP请求到example.com的服务器的80端口。该个请求的语法如下所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/</span> HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="string">example.org</span></span><br></pre></td></tr></table></figure>
<p>​    以上第一行叫做请求行，第二个参数(一个反斜线在这个例子中)表示所请求资源的路径。反斜线代表了根目录;服务器会转换这个根目录为服务器文件系统中的一个具体目录。</p>
<p>​    Apache的用户常用DocumentRoot这个命令来设置这个文档根路径。如果请求的url是<a href="undefined">HTTP://example.org/path/to/sc…</a>那么请求的路径就是<code>/path/to/script.php</code>。假如document root 被定义为<code>usr/lcoal/apache/htdocs</code>的话,整个请求的资源路径就是<code>/usr/local/apache/htdocs/path/to/script.php</code>。</p>
<p>​    第二行描述的是HTTP头部的语法。在这个例子中的头部是Host, 它标识了浏览器希望获取资源的域名主机。还有很多其它的请求头部可以包含在HTTP请求中，比如user-Agent头部，在php可以通过<code>$_SERVER[&#39;HTTP_USER_AGENT&#39;]</code>获取请求中所携带的这个头部信息。</p>
<h2 id="HTTP前世今生">HTTP前世今生</h2><h3 id="HTTP_0-9">HTTP 0.9</h3><p>​    最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令<code>GET</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html</span><br></pre></td></tr></table></figure>
<p>​    上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>​    服务器发送完毕，就关闭TCP连接。</p>
<h3 id="HTTP1-0">HTTP1.0</h3><p>​    1996年5月，HTTP/1.0 版本发布，内容大大增加。首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>
<h4 id="短暂连接的缺陷">短暂连接的缺陷</h4><p>​    HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求：</p>
<p><img src="https://ooo.0o0.ooo/2016/08/24/57bd53f7b4ad8.jpg" alt="1.jpg"></p>
<p>​    显然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一 次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。当一个网页文件中包含Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。</p>
<h3 id="HTTP1-1">HTTP1.1</h3><h4 id="持久连接">持久连接</h4><p>​    在HTTP1.0中，每对Request/Response都使用一个新的连接。HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪 每个客户也不记录过去的请求。此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。</p>
<p><img src="https://ooo.0o0.ooo/2016/08/24/57bd53f7bdeba.jpg" alt="2.jpg"></p>
<h4 id="管道机制">管道机制</h4><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h4 id="分块传输编码">分块传输编码</h4><p>​    <strong>分块传输编码</strong>（<strong>Chunked transfer encoding</strong>）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由应用服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。通常数据块的大小是一致的，但也不总是这种情况。</p>
<p>​    HTTP 1.1引入分块传输编码提供了以下几点好处：</p>
<ol>
<li>HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久连接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。<strong>[动态内容，content-length无法预知]</strong></li>
<li>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。<strong>[散列签名，需缓冲完成才能计算]</strong></li>
<li>HTTP服务器有时使用压缩 （gzip或deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。<strong>[gzip压缩，压缩与传输同时进行]</strong></li>
</ol>
<p>​    一般情况HTTP的Header包含Content-Length域来指明报文体的长度。有时候服务生成HTTP回应是无法确定消息大小的，比如大文件的下载，或者后台需要复杂的逻辑才能全部处理页面的请求，这时用需要实时生成消息长度，服务器一般使用chunked编码。在进行Chunked编码传输时，在回复消息的Headers有transfer-coding域值为chunked，表示将用chunked编码传输内容。使用chunked编码的Headers如下（可以利用FireFox的FireBug插件或HttpWatch查看Headers信息）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">　　Chunked-Body=*chunk   </span><br><span class="line">  　　　　　　　　　"0"CRLF   </span><br><span class="line">  　　　　　　　　　footer   </span><br><span class="line">  　　　　　　　　　CRLF   </span><br><span class="line">  　　chunk=chunk-size[chunk-ext]CRLF   </span><br><span class="line">  　　　　　　chunk-dataCRLF   </span><br><span class="line">    </span><br><span class="line">  　　hex-no-zero=&lt;HEXexcluding"0"&gt;   </span><br><span class="line">    </span><br><span class="line">  　　chunk-size=hex-no-zero*HEX   </span><br><span class="line">  　　chunk-ext=*(";"chunk-ext-name["="chunk-ext-value])   </span><br><span class="line">  　　chunk-ext-name=token   </span><br><span class="line">  　　chunk-ext-val=token|quoted-string   </span><br><span class="line">  　　chunk-data=chunk-size(OCTET)   </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  　　footer=*entity-header</span><br></pre></td></tr></table></figure>
<p>​    编码使用若干个Chunk组成，由一个标明长度为0的chunk结束，每个Chunk有两部分组成，第一部分是该Chunk的长度和长度单位（一般不 写），第二部分就是指定长度的内容，每个部分用CRLF隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些没有写的头部内容。下面给出一个Chunked的解码过程（RFC文档中有）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  　　length:=0   </span><br><span class="line">  　　readchunk-size,chunk-ext(ifany)andCRLF   </span><br><span class="line">  　　while(chunk-size&gt;0)&#123;   </span><br><span class="line">  　　readchunk-dataandCRLF   </span><br><span class="line">  　　appendchunk-datatoentity-body   </span><br><span class="line">  　　length:=length+chunk-size   </span><br><span class="line">  　　readchunk-sizeandCRLF   </span><br><span class="line">  　　&#125;   </span><br><span class="line">  　　readentity-header   </span><br><span class="line">  　　while(entity-headernotempty)&#123;   </span><br><span class="line">  　　appendentity-headertoexistingheaderfields   </span><br><span class="line">  　　readentity-header   </span><br><span class="line">  　　&#125;   </span><br><span class="line">  　　Content-Length:=length   </span><br><span class="line">  　　Remove"chunked"fromTransfer-Encoding</span><br></pre></td></tr></table></figure>
<h3 id="HTTP2">HTTP2</h3><h4 id="二进制协议支持">二进制协议支持</h4><p>​    HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>
<h4 id="多工复用">多工复用</h4><p>​    HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。这样双向的、实时的通信，就叫做多工（Multiplexing）。</p>
<h4 id="数据流">数据流</h4><p>​    因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
<h4 id="头信息压缩">头信息压缩</h4><p>​    HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h4 id="服务器推送">服务器推送</h4><p>​    HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
<h2 id="HTTP_General_Header:HTTP_通用头">HTTP General Header:HTTP 通用头</h2><p>​    就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message-header，即<strong>HTTP</strong> <strong>header</strong>消息。HTTP header 消息通常被分为4个部分：general header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对HTTP header内容的组织形式，大体分为Request和Response两部分。笔者在这里只是对于常见的协议头内容做一个列举，不同的设置会有不同的功能效果，会在下文中详细说明。本部分只介绍请求头的通用构成，具体的请求与响应参考各自章节。</p>
<blockquote>
<p><strong>注意每个Header的冒号后面有个空格</strong></p>
</blockquote>
<p>​    通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。</p>
<h3 id="Date">Date</h3><p>​    Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。</p>
<h3 id="Pragma">Pragma</h3><p>​    Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。</p>
<h3 id="Entity">Entity</h3><p>​    请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、 Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体 头，但是这些域可能无法未接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定 义，它的长度由Content-Length或Content-Range定义。</p>
<h3 id="Content-Type">Content-Type</h3><p>​    Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型Content-Range实体头。关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式。Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth</span></span><br></pre></td></tr></table></figure>
<p>​    Content-Type表明信息类型，缺省值为” text/plain”。它包含了主要类型（primary type）和次要类型（subtype）两个部分，两者之间用”/“分割。主要类型有9种，分别是application、audio、example、image、message、model、multipart、text、video。每一种主要类型下面又有许多种次要类型，常见的有：</p>
<ul>
<li>text/plain：纯文本，文件扩展名.txt</li>
<li>text/html：HTML文本，文件扩展名.htm和.html</li>
<li>image/jpeg：jpeg格式的图片，文件扩展名.jpg</li>
<li>image/gif：GIF格式的图片，文件扩展名.gif</li>
<li>audio/x-wave：WAVE格式的音频，文件扩展名.wav</li>
<li>audio/mpeg：MP3格式的音频，文件扩展名.mp3</li>
<li>video/mpeg：MPEG格式的视频，文件扩展名.mpg</li>
<li>application/zip：PK-ZIP格式的压缩文件，文件扩展名.zip</li>
</ul>
<h3 id="Content-Length">Content-Length</h3><p>​    TCP 1.0中允许单个TCP连接可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。</p>
<h3 id="Content-Encoding">Content-Encoding</h3><p>​    由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span>: <span class="string">gzip</span></span><br><span class="line"><span class="attribute">Content-Encoding</span>: <span class="string">compress</span></span><br><span class="line"><span class="attribute">Content-Encoding</span>: <span class="string">deflate</span></span><br></pre></td></tr></table></figure>
<p>​    客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>
<h3 id="HTTP_Lint">HTTP Lint</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Lint for HTTP:HTTPolice]()</span><br></pre></td></tr></table></figure>
<p>​    HTTPolice是一个简单的基于命令行的对于HTTP请求格式规范进行检测的工具，可以直接使用<code>pip</code>命令进行安装:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install HTTPolice</span><br></pre></td></tr></table></figure>
<p>​    当我们使用Google Chrome、Firefox或者Microsoft Edge进行网络访问时，可以使用开发者工具导出某个HAR文件，这也就是HTTP Lint工具可以用来解析的文件。使用如下命令进行分析:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ httpolice -i har /path/to/file.har</span><br><span class="line">------------ request: GET /<span class="number">1441</span>/<span class="number">25776044114</span>_0e5b9879a0_z.jpg------------ response: <span class="number">200</span> OKC <span class="number">1277</span> Obsolete <span class="string">'X-'</span> prefix <span class="keyword">in</span> X-Photo-FarmC <span class="number">1277</span> Obsolete <span class="string">'X-'</span> prefix <span class="keyword">in</span> X-Photo-OriginE <span class="number">1000</span> Malformed Expires headerE <span class="number">1241</span> Date + Age is <span class="keyword">in</span> the future</span><br></pre></td></tr></table></figure>
<p>​    默认的HTTPolice以文本形式输出报告文本，如下所示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------------ request: PUT /articles/109226/</span><br><span class="line">E 1000 Malformed If-Match header</span><br><span class="line">C 1093 User-Agent contains no actual product</span><br><span class="line">------------ response: 204 No Content</span><br><span class="line">C 1110 204 response with no Date header</span><br><span class="line">E 1221 Strict-Transport-Security without TLS</span><br><span class="line">------------ request: POST /articles/109226/comments/</span><br></pre></td></tr></table></figure>
<p>​    纯文本的方式可能比较难以理解，我们可以使用<code>-o html</code>选项来设置更详细的基于HTML风格的输出，譬如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ httpolice -i har -o html /path/to/file.har &gt;report.html</span><br></pre></td></tr></table></figure>
<p> <img src="https://ooo.0o0.ooo/2016/08/24/57bd53f7f3f19.jpg" alt="3.jpg"></p>
<h3 id="转载来自此链接"><a href="https://segmentfault.com/a/1190000006689489#articleHeader11" target="_blank" rel="external"><strong>转载来自此链接</strong></a></h3>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://www.yuluoding.com/2016/08/24/HTTP基础和变迁/" data-id="ciz0063vf003odrjr3bi2wmtm" class="article-share-link" data-share="baidu">Share</a>
      

      
        <a href="http://www.yuluoding.com/2016/08/24/HTTP基础和变迁/#ds-thread" class="article-comment-link">Comments</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/08/25/Xposed-is-installed-but-not-actived/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Xposed is installed but not actived
        
      </div>
    </a>
  
  
    <a href="/2016/08/22/IMEI和MEID的区别/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">IMEI和MEID的区别</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    
  <div class="ds-thread" data-thread-key="2016/08/24/HTTP基础和变迁/" data-title="HTTP基础和变迁" data-url="http://www.yuluoding.com/2016/08/24/HTTP基础和变迁/"></div>
  
<script type="text/javascript">
var duoshuoQuery = {short_name:"xuelu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>


  </section>



<div class="ds-share" data-thread-key="2016/08/24/HTTP基础和变迁/" data-title="HTTP基础和变迁" data-images="此处请替换为分享时显示的图片的链接地址" data-content="&lt;h2 id=&quot;HTTP&quot;&gt;HTTP&lt;/h2&gt;&lt;p&gt;​    HTTP（HyperTextTransferProtocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP 协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户 信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。&lt;br&gt;HTTP是一种无状态性的协议。这是因为此种协议不要求浏览器在每次请求中标明它自己的身份，并且浏览器以及服务器之间并没有保持一个持久性的连接用于多个页面之间的访问。当一个用户访问一个站点的时候，用户的浏览器发送一个HTTP请求到服务器，服务器返回给浏览器一个HTTP响应。其实很简单的一个概念，客户端一个请求，服务器端一个回复，这就是整个基于HTTP协议的通讯过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;URL&quot;&gt;URL&lt;/h3&gt;&lt;p&gt;​    在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫URL（Uniform Resource Locator,统一资源定位符），它是WWW的统一资源定位标志。URL分为绝对URL与相对URL两种。绝对URL和访问时的状态完全无关。与之相对应的是省略了部分信息的相对（relative）URL，如../file.php?text=hello+world，它需要根据当前浏览所在上下文环境里的基准URL，才能确定完整的URL地址。&lt;/p&gt;
&lt;p&gt;​    URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。URL的一般语法格式为：(带方括号[]的为可选项)：&lt;code&gt;protocol :// hostname[:port] / path / ;parameters#fragment&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;消息格式&quot;&gt;消息格式&lt;/h3&gt;&lt;p&gt;​    通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。HTTP的头域包括&lt;strong&gt;通用头，请求头，响应头和实体头&lt;/strong&gt;四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。&lt;/p&gt;
&lt;p&gt;​    当用户访问&lt;a href=&quot;HTTP://example.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HTTP://example.com&lt;/a&gt;这个域名的时候，浏览器就会自动和服务器建立tcp/ip连接，然后发送HTTP请求到example.com的服务器的80端口。该个请求的语法如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;request&quot;&gt;GET &lt;span class=&quot;string&quot;&gt;/&lt;/span&gt; HTTP/1.1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Host&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;example.org&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    以上第一行叫做请求行，第二个参数(一个反斜线在这个例子中)表示所请求资源的路径。反斜线代表了根目录;服务器会转换这个根目录为服务器文件系统中的一个具体目录。&lt;/p&gt;
&lt;p&gt;​    Apache的用户常用DocumentRoot这个命令来设置这个文档根路径。如果请求的url是&lt;a href=&quot;undefined&quot;&gt;HTTP://example.org/path/to/sc…&lt;/a&gt;那么请求的路径就是&lt;code&gt;/path/to/script.php&lt;/code&gt;。假如document root 被定义为&lt;code&gt;usr/lcoal/apache/htdocs&lt;/code&gt;的话,整个请求的资源路径就是&lt;code&gt;/usr/local/apache/htdocs/path/to/script.php&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;​    第二行描述的是HTTP头部的语法。在这个例子中的头部是Host, 它标识了浏览器希望获取资源的域名主机。还有很多其它的请求头部可以包含在HTTP请求中，比如user-Agent头部，在php可以通过&lt;code&gt;$_SERVER[&amp;#39;HTTP_USER_AGENT&amp;#39;]&lt;/code&gt;获取请求中所携带的这个头部信息。&lt;/p&gt;
&lt;h2 id=&quot;HTTP前世今生&quot;&gt;HTTP前世今生&lt;/h2&gt;&lt;h3 id=&quot;HTTP_0-9&quot;&gt;HTTP 0.9&lt;/h3&gt;&lt;p&gt;​    最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令&lt;code&gt;GET&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GET /index.html&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页&lt;code&gt;index.html&lt;/code&gt;。协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;body&amp;gt;Hello World&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    服务器发送完毕，就关闭TCP连接。&lt;/p&gt;
&lt;h3 id=&quot;HTTP1-0&quot;&gt;HTTP1.0&lt;/h3&gt;&lt;p&gt;​    1996年5月，HTTP/1.0 版本发布，内容大大增加。首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。其次，除了&lt;code&gt;GET&lt;/code&gt;命令，还引入了&lt;code&gt;POST&lt;/code&gt;命令和&lt;code&gt;HEAD&lt;/code&gt;命令，丰富了浏览器与服务器的互动手段。再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。&lt;/p&gt;
&lt;h4 id=&quot;短暂连接的缺陷&quot;&gt;短暂连接的缺陷&lt;/h4&gt;&lt;p&gt;​    HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的&lt;img&gt;图像标签后，浏览器将根据&lt;img&gt;标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/08/24/57bd53f7b4ad8.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;​    显然，访问一个包含有许多图像的网页文件的整个过程包含了多次请求和响应，每次请求和响应都需要建立一个单独的连接，每次连接只是传输一个文档和图像，上一 次和下一次请求完全分离。即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性 能。当一个网页文件中包含Applet，JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。&lt;/p&gt;
&lt;h3 id=&quot;HTTP1-1&quot;&gt;HTTP1.1&lt;/h3&gt;&lt;h4 id=&quot;持久连接&quot;&gt;持久连接&lt;/h4&gt;&lt;p&gt;​    在HTTP1.0中，每对Request/Response都使用一个新的连接。HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪 每个客户也不记录过去的请求。此外，由于大多数网页的流量都比较小，一次TCP连接很少能通过slow-start区，不利于提高带宽利用率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/08/24/57bd53f7bdeba.jpg&quot; alt=&quot;2.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;管道机制&quot;&gt;管道机制&lt;/h4&gt;&lt;p&gt;1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。&lt;/p&gt;
&lt;h4 id=&quot;分块传输编码&quot;&gt;分块传输编码&lt;/h4&gt;&lt;p&gt;​    &lt;strong&gt;分块传输编码&lt;/strong&gt;（&lt;strong&gt;Chunked transfer encoding&lt;/strong&gt;）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由应用服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。通常，HTTP应答消息中发送的数据是整个发送的，Content-Length消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。通常数据块的大小是一致的，但也不总是这种情况。&lt;/p&gt;
&lt;p&gt;​    HTTP 1.1引入分块传输编码提供了以下几点好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久连接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。&lt;strong&gt;[动态内容，content-length无法预知]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。&lt;strong&gt;[散列签名，需缓冲完成才能计算]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;HTTP服务器有时使用压缩 （gzip或deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。&lt;strong&gt;[gzip压缩，压缩与传输同时进行]&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    一般情况HTTP的Header包含Content-Length域来指明报文体的长度。有时候服务生成HTTP回应是无法确定消息大小的，比如大文件的下载，或者后台需要复杂的逻辑才能全部处理页面的请求，这时用需要实时生成消息长度，服务器一般使用chunked编码。在进行Chunked编码传输时，在回复消息的Headers有transfer-coding域值为chunked，表示将用chunked编码传输内容。使用chunked编码的Headers如下（可以利用FireFox的FireBug插件或HttpWatch查看Headers信息）：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;　　Chunked-Body=*chunk   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　　　　　　　　&quot;0&quot;CRLF   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　　　　　　　　footer   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　　　　　　　　CRLF   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　chunk=chunk-size[chunk-ext]CRLF   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　　　　　chunk-dataCRLF   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　hex-no-zero=&amp;lt;HEXexcluding&quot;0&quot;&amp;gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　chunk-size=hex-no-zero*HEX   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　chunk-ext=*(&quot;;&quot;chunk-ext-name[&quot;=&quot;chunk-ext-value])   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　chunk-ext-name=token   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　chunk-ext-val=token|quoted-string   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　chunk-data=chunk-size(OCTET)   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　footer=*entity-header&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    编码使用若干个Chunk组成，由一个标明长度为0的chunk结束，每个Chunk有两部分组成，第一部分是该Chunk的长度和长度单位（一般不 写），第二部分就是指定长度的内容，每个部分用CRLF隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些没有写的头部内容。下面给出一个Chunked的解码过程（RFC文档中有）：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  　　length:=0   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　readchunk-size,chunk-ext(ifany)andCRLF   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　while(chunk-size&amp;gt;0)&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　readchunk-dataandCRLF   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　appendchunk-datatoentity-body   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　length:=length+chunk-size   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　readchunk-sizeandCRLF   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　readentity-header   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　while(entity-headernotempty)&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　appendentity-headertoexistingheaderfields   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　readentity-header   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　&amp;#125;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　Content-Length:=length   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  　　Remove&quot;chunked&quot;fromTransfer-Encoding&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;HTTP2&quot;&gt;HTTP2&lt;/h3&gt;&lt;h4 id=&quot;二进制协议支持&quot;&gt;二进制协议支持&lt;/h4&gt;&lt;p&gt;​    HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。&lt;/p&gt;
&lt;h4 id=&quot;多工复用&quot;&gt;多工复用&lt;/h4&gt;&lt;p&gt;​    HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。这样双向的、实时的通信，就叫做多工（Multiplexing）。&lt;/p&gt;
&lt;h4 id=&quot;数据流&quot;&gt;数据流&lt;/h4&gt;&lt;p&gt;​    因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。&lt;/p&gt;
&lt;h4 id=&quot;头信息压缩&quot;&gt;头信息压缩&lt;/h4&gt;&lt;p&gt;​    HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。&lt;/p&gt;
&lt;h4 id=&quot;服务器推送&quot;&gt;服务器推送&lt;/h4&gt;&lt;p&gt;​    HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。&lt;/p&gt;
&lt;h2 id=&quot;HTTP_General_Header:HTTP_通用头&quot;&gt;HTTP General Header:HTTP 通用头&lt;/h2&gt;&lt;p&gt;​    就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message-header，即&lt;strong&gt;HTTP&lt;/strong&gt; &lt;strong&gt;header&lt;/strong&gt;消息。HTTP header 消息通常被分为4个部分：general header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对HTTP header内容的组织形式，大体分为Request和Response两部分。笔者在这里只是对于常见的协议头内容做一个列举，不同的设置会有不同的功能效果，会在下文中详细说明。本部分只介绍请求头的通用构成，具体的请求与响应参考各自章节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意每个Header的冒号后面有个空格&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、 Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。&lt;/p&gt;
&lt;h3 id=&quot;Date&quot;&gt;Date&lt;/h3&gt;&lt;p&gt;​    Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。&lt;/p&gt;
&lt;h3 id=&quot;Pragma&quot;&gt;Pragma&lt;/h3&gt;&lt;p&gt;​    Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache-Control:no-cache相同。&lt;/p&gt;
&lt;h3 id=&quot;Entity&quot;&gt;Entity&lt;/h3&gt;&lt;p&gt;​    请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、 Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体 头，但是这些域可能无法未接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定 义，它的长度由Content-Length或Content-Range定义。&lt;/p&gt;
&lt;h3 id=&quot;Content-Type&quot;&gt;Content-Type&lt;/h3&gt;&lt;p&gt;​    Content-Type实体头用于向接收方指示实体的介质类型，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型Content-Range实体头。关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式。Content-Range实体头用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：&lt;/p&gt;
&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-legth&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    Content-Type表明信息类型，缺省值为” text/plain”。它包含了主要类型（primary type）和次要类型（subtype）两个部分，两者之间用”/“分割。主要类型有9种，分别是application、audio、example、image、message、model、multipart、text、video。每一种主要类型下面又有许多种次要类型，常见的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;text/plain：纯文本，文件扩展名.txt&lt;/li&gt;
&lt;li&gt;text/html：HTML文本，文件扩展名.htm和.html&lt;/li&gt;
&lt;li&gt;image/jpeg：jpeg格式的图片，文件扩展名.jpg&lt;/li&gt;
&lt;li&gt;image/gif：GIF格式的图片，文件扩展名.gif&lt;/li&gt;
&lt;li&gt;audio/x-wave：WAVE格式的音频，文件扩展名.wav&lt;/li&gt;
&lt;li&gt;audio/mpeg：MP3格式的音频，文件扩展名.mp3&lt;/li&gt;
&lt;li&gt;video/mpeg：MPEG格式的视频，文件扩展名.mpg&lt;/li&gt;
&lt;li&gt;application/zip：PK-ZIP格式的压缩文件，文件扩展名.zip&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Content-Length&quot;&gt;Content-Length&lt;/h3&gt;&lt;p&gt;​    TCP 1.0中允许单个TCP连接可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。&lt;/p&gt;
&lt;h3 id=&quot;Content-Encoding&quot;&gt;Content-Encoding&lt;/h3&gt;&lt;p&gt;​    由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。&lt;code&gt;Content-Encoding&lt;/code&gt;字段说明数据的压缩方法。&lt;/p&gt;
&lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Content-Encoding&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;gzip&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Content-Encoding&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;compress&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Content-Encoding&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;deflate&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    客户端在请求时，用&lt;code&gt;Accept-Encoding&lt;/code&gt;字段说明自己可以接受哪些压缩方法。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Accept-Encoding: gzip, deflate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;HTTP_Lint&quot;&gt;HTTP Lint&lt;/h3&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[Lint for HTTP:HTTPolice]()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    HTTPolice是一个简单的基于命令行的对于HTTP请求格式规范进行检测的工具，可以直接使用&lt;code&gt;pip&lt;/code&gt;命令进行安装:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install HTTPolice&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    当我们使用Google Chrome、Firefox或者Microsoft Edge进行网络访问时，可以使用开发者工具导出某个HAR文件，这也就是HTTP Lint工具可以用来解析的文件。使用如下命令进行分析:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ httpolice -i har /path/to/file.har&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------ request: GET /&lt;span class=&quot;number&quot;&gt;1441&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;25776044114&lt;/span&gt;_0e5b9879a0_z.jpg------------ response: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt; OKC &lt;span class=&quot;number&quot;&gt;1277&lt;/span&gt; Obsolete &lt;span class=&quot;string&quot;&gt;&#39;X-&#39;&lt;/span&gt; prefix &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; X-Photo-FarmC &lt;span class=&quot;number&quot;&gt;1277&lt;/span&gt; Obsolete &lt;span class=&quot;string&quot;&gt;&#39;X-&#39;&lt;/span&gt; prefix &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; X-Photo-OriginE &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt; Malformed Expires headerE &lt;span class=&quot;number&quot;&gt;1241&lt;/span&gt; Date + Age is &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the future&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    默认的HTTPolice以文本形式输出报告文本，如下所示&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;------------ request: PUT /articles/109226/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E 1000 Malformed If-Match header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C 1093 User-Agent contains no actual product&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------ response: 204 No Content&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C 1110 204 response with no Date header&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E 1221 Strict-Transport-Security without TLS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;------------ request: POST /articles/109226/comments/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​    纯文本的方式可能比较难以理解，我们可以使用&lt;code&gt;-o html&lt;/code&gt;选项来设置更详细的基于HTML风格的输出，譬如:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ httpolice -i har -o html /path/to/file.har &amp;gt;report.html&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; &lt;img src=&quot;https://ooo.0o0.ooo/2016/08/24/57bd53f7f3f19.jpg&quot; alt=&quot;3.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;转载来自此链接&quot;&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006689489#articleHeader11&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;转载来自此链接&lt;/strong&gt;&lt;/a&gt;&lt;/h3&gt;" data-url="http://www.yuluoding.com/2016/08/24/HTTP基础和变迁/">
    <div class="ds-share-inline">
      <ul  class="ds-share-icons-16">
        
        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
        
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>


</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget category">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-Studio/">Android Studio</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Apple/">Apple</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GIT/">GIT</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Google/">Google</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Soft/">Soft</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Study-Class/">Study Class</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xposed/">Xposed</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo教程/">hexo教程</a><span class="category-list-count">6</span></li></ul>
      	
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/20/Xshell配色方案/">Xshell配色方案</a>
          </li>
        
          <li>
            <a href="/2017/01/17/Python两个字典的合并/">Python两个字典的合并</a>
          </li>
        
          <li>
            <a href="/2017/01/12/Pyhton的文件操作/">Pyhton的文件操作</a>
          </li>
        
          <li>
            <a href="/2017/01/09/Linux提示Give-root-password-for-maintenance/">Linux提示Give root password for maintenance</a>
          </li>
        
          <li>
            <a href="/2016/12/30/Python创建目录/">Python创建目录</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://xiguabaobao.com" target="_blank">auther</a>
          </li>
        
          <li>
            <a href="" target="_blank">sina</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Luo Yu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"xuelu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>window._bd_share_config={"common":{},"share":{"bdCustomStyle":"/css/bdshare.css"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>

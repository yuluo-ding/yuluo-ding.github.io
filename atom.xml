<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yuluo</title>
  
  <subtitle>The home of yuluo!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="yuluo-ding.github.io/"/>
  <updated>2020-12-16T09:39:38.666Z</updated>
  <id>yuluo-ding.github.io/</id>
  
  <author>
    <name>Luo Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Debian上使用UFW</title>
    <link href="yuluo-ding.github.io/2020/12/16/%E5%9C%A8Debian%E4%B8%8A%E4%BD%BF%E7%94%A8UFW/"/>
    <id>yuluo-ding.github.io/2020/12/16/在Debian上使用UFW/</id>
    <published>2020-12-16T08:36:26.000Z</published>
    <updated>2020-12-16T09:39:38.666Z</updated>
    
    <content type="html"><![CDATA[<p>UFW全程Uncomplicated Firewall，是Ubuntu系统上默认的防火墙组件。UFW是为轻量化配置iptables而开发的一款工具。UFW 提供一个非常友好的界面用于创建基于IPV4，IPV6的防火墙规则。UFW 在 Ubuntu 8.04 LTS 后的所有发行版中默认可用。无论是桌面版还是服务器版，UFW 的命令行用法是一样的。</p><p>在服务器上使用UFW的时候需要具备<code>sudo</code>权限</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Debian 默认不安装UFW，使用如下命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y UFW</span><br></pre></td></tr></table></figure><h3 id="将IPv6与UFW一起使用-可选"><a href="#将IPv6与UFW一起使用-可选" class="headerlink" title="将IPv6与UFW一起使用(可选)"></a>将IPv6与UFW一起使用(可选)</h3><p>默认是不启用IPv6，如果需要开启，则需要用vi编辑UFW的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/default/ufw</span><br></pre></td></tr></table></figure><p>然后把<code>no</code>改成<code>yes</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPV6=yes</span><br></pre></td></tr></table></figure><h3 id="设置默认策略"><a href="#设置默认策略" class="headerlink" title="设置默认策略"></a>设置默认策略</h3><p>刚开始使用的时候，需要设置默认策略，这些规则控制如何处理未明确匹配任何其他规则的流量。UFW设置为拒绝所有传入连接并允许所有传出连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow ssh</span><br></pre></td></tr></table></figure><p>这将创建防火墙规则，允许端口<code>22</code>上的所有连接，这是SSH守护程序默认侦听的端口。UFW知道端口<code>allow ssh</code>的含义，因为它在<code>/etc/services</code>文件中被列为服务。</p><p>但是，实际上可以通过指定端口而不是服务名来编写等效规则。例如，此命令与上面的命令相同：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 22</span><br></pre></td></tr></table></figure><p>如果将SSH守护程序配置为使用其他端口，则必须指定相应的端口。例如，如果SSH服务器正在侦听端口<code>2222</code>，则可以使用此命令允许该端口上的连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 2222</span><br></pre></td></tr></table></figure><p>现在您的防火墙已配置为允许传入SSH连接，我们可以启用它。</p><h3 id="启用UFW"><a href="#启用UFW" class="headerlink" title="启用UFW"></a>启用UFW</h3><p>要启用UFW，请使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p>您将收到一条警告，指出该命令可能会破坏现有的SSH连接。我们已经设置了允许SSH连接的防火墙规则，因此可以继续。用<code>y</code>来响应提示然后点击<code>ENTER</code>。</p><p>防火墙现在处于活动状态。运行该<code>sudo ufw status verbose</code>命令以查看已设置的规则。</p><p><img src="https://i.loli.net/2020/12/16/LlzDS78O32Es5kx.png" alt="ufw.png"></p><h3 id="设置其他规则"><a href="#设置其他规则" class="headerlink" title="设置其他规则"></a>设置其他规则</h3><p>此时也可以这样做：</p><ul><li>端口80上的HTTP，这是未加密的Web服务器使用的，使用<code>sudo ufw allow http</code>或<code>sudo ufw allow 80</code></li><li>端口443上的HTTPS，这是加密的Web服务器使用的，使用<code>sudo ufw allow https</code>或<code>sudo ufw allow 443</code></li></ul><p>除了指定端口或已知服务之外，还有其他几种允许其他连接的方法。</p><h4 id="特定端口范围"><a href="#特定端口范围" class="headerlink" title="特定端口范围"></a>特定端口范围</h4><p>可以使用UFW指定端口范围。某些应用程序使用多个端口，而不是单个端口。</p><p>例如，为了允许X11连接，它使用的是端口<code>6000</code>- <code>6007</code>，使用这些命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 6000:6007/tcp</span><br><span class="line">sudo ufw allow 6000:6007/udp</span><br></pre></td></tr></table></figure><p>使用UFW指定端口范围时，必须指定规则应适用的协议（<code>tcp</code>或<code>udp</code>）。否则就是默认自动启用两种协议。</p><h4 id="特定IP地址"><a href="#特定IP地址" class="headerlink" title="特定IP地址"></a>特定IP地址</h4><p>使用UFW时，还可以指定IP地址。例如，如果要允许来自特定IP地址的连接（例如工作或家庭IP地址为<code>203.0.113.5</code>），则需要指定<code>from</code>，然后才是IP地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow <span class="keyword">from</span> <span class="number">203.0</span><span class="number">.113</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>同样，也可以指定允许子网<code>203.0.113.0/24</code>连接的目标端口。使用端口<code>22</code>（SSH）作为示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow <span class="keyword">from</span> <span class="number">203.0</span><span class="number">.113</span><span class="number">.0</span>/<span class="number">24</span> to any port <span class="number">22</span></span><br></pre></td></tr></table></figure><h4 id="与特定网络接口的连接"><a href="#与特定网络接口的连接" class="headerlink" title="与特定网络接口的连接"></a>与特定网络接口的连接</h4><p>如果要创建仅适用于特定网络接口的防火墙规则，可以通过指定“允许接通”，然后指定网络接口的名称来执行此操作。</p><p>在继续之前查找网络接口。为此，请使用以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br><span class="line"><span class="number">2</span>: eth0: <span class="xml"><span class="tag">&lt;<span class="name">BROADCAST,MULTICAST,UP,LOWER_UP</span>&gt;</span> mtu 1500 qdisc pfifo_fast state</span></span><br><span class="line"><span class="xml">. . .</span></span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><p>突出显示的输出表示网络接口名称。它们通常被命名为<code>eth0</code>或者<code>enp3s2</code>。</p><p>因此，如果服务器有一个名叫<code>eth0</code>的公共网络接口，则可以使用以下命令允许HTTP流量（端口<code>80</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow <span class="keyword">in</span> on eth0 to any port <span class="number">80</span></span><br></pre></td></tr></table></figure><p>这样做将允许服务器从公共互联网接收HTTP请求。</p><p>或者，如果希望MySQL数据库服务器（端口<code>3306</code>）侦听专用网络接口<code>eth1</code>上的连接，例如，可以使用此命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow <span class="keyword">in</span> on eth1 to any port <span class="number">3306</span></span><br></pre></td></tr></table></figure><p>这将允许专用网络上的其他服务器连接到MySQL数据库。</p><h3 id="拒绝连接"><a href="#拒绝连接" class="headerlink" title="拒绝连接"></a>拒绝连接</h3><p>如果尚未更改传入连接的默认策略，则UFW配置为拒绝所有传入连接。</p><p>但是，有时希望根据源IP地址或子网拒绝特定连接，可能是因为您知道您的服务器正在受到攻击。此外，如果要将默认传入策略更改为<strong>允许</strong>（不建议这样做），则需要为不希望允许连接的任何服务或IP地址创建<strong>拒绝</strong>规则。</p><p>要编写<strong>拒绝</strong>规则，可以使用上述命令，将<strong>allow</strong>替换为<strong>deny</strong>。</p><p>例如，要拒绝HTTP连接，可以使用以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw deny http</span><br></pre></td></tr></table></figure><p>或者，如果要拒绝来自<code>203.0.113.5</code>上的所有连接，可以使用以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw deny <span class="keyword">from</span> <span class="number">203.0</span><span class="number">.113</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><h3 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><p>了解如何删除防火墙规则与了解如何创建防火墙规则同样重要。有两种不同的方法可以指定要删除的规则：按规则编号或实际规则（类似于创建规则时的规则）。</p><h4 id="按规则编号"><a href="#按规则编号" class="headerlink" title="按规则编号"></a>按规则编号</h4><p>如果使用规则编号删除防火墙规则，那么要做的第一件事就是获取防火墙规则列表。UFW status命令可以选择显示每个规则旁边的数字，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status numbered</span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">     To                         Action      From</span><br><span class="line">     --                         ------      ----</span><br><span class="line">[ <span class="number">1</span>] <span class="number">22</span>                         ALLOW IN    <span class="number">15.15</span><span class="number">.15</span><span class="number">.0</span>/<span class="number">24</span></span><br><span class="line">[ <span class="number">2</span>] <span class="number">80</span>                         ALLOW IN    Anywhere</span><br></pre></td></tr></table></figure><p>如果决定要删除允许端口80（HTTP）连接的规则2，可以在UFW删除命令中指定它，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="keyword">delete</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这将显示确认提示，然后删除规则2，允许HTTP连接。请注意，如果启用了IPv6，则还需要删除相应的IPv6规则。</p><h4 id="按实际规则"><a href="#按实际规则" class="headerlink" title="按实际规则"></a>按实际规则</h4><p>规则编号的替代方法是指定要删除的实际规则。例如，如果要删除<code>allow http</code>规则，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="keyword">delete</span> allow http</span><br></pre></td></tr></table></figure><p>还可以通过<code>allow 80</code>而不是按服务名称来指定规则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="keyword">delete</span> allow <span class="number">80</span></span><br></pre></td></tr></table></figure><p>此方法将删除IPv4和IPv6规则（如果存在）。</p><h3 id="检查UFW状态和规则"><a href="#检查UFW状态和规则" class="headerlink" title="检查UFW状态和规则"></a>检查UFW状态和规则</h3><p>可以随时使用以下命令检查UFW的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status verbose</span><br></pre></td></tr></table></figure><p>如果UFW被禁用，默认情况下，会看到如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status: inactive</span><br></pre></td></tr></table></figure><p>如果UFW处于活动状态，如果您按照步骤进行操作，输出将表明它处于活动状态，并且它将列出所有已设置的规则。例如，如果防火墙设置为允许来自任何位置的SSH（端口<code>22</code>）连接，则输出可能如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status: active</span><br><span class="line">Logging: on (low)</span><br><span class="line">Default: deny (incoming), allow (outgoing), disabled (routed)</span><br><span class="line">New profiles: skip</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line"><span class="number">22</span>/tcp                     ALLOW IN    Anywhere</span><br></pre></td></tr></table></figure><p>如果要检查UFW如何配置防火墙，请使用此<code>status</code>命令。</p><h3 id="禁用或重置UFW"><a href="#禁用或重置UFW" class="headerlink" title="禁用或重置UFW"></a>禁用或重置UFW</h3><p>如果决定不想使用UFW，可以使用以下命令禁用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure><p>使用UFW创建的任何规则将不再处于活动状态。如果以后需要激活，可以随时运行<code>sudo ufw enable</code>。</p><p>如果已经配置了UFW规则但是决定要重新开始，则可以使用reset命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw reset</span><br></pre></td></tr></table></figure><p>这将禁用UFW并删除先前定义的任何规则。请注意，如果在任何时候修改了默认策略，默认策略都不会更改为原始设置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UFW全程Uncomplicated Firewall，是Ubuntu系统上默认的防火墙组件。UFW是为轻量化配置iptables而开发的一款工具。UFW 提供一个非常友好的界面用于创建基于IPV4，IPV6的防火墙规则。UFW 在 Ubuntu 8.04 LTS 后的所有发行版中默认可用。无论是桌面版还是服务器版，UFW 的命令行用法是一样的。&lt;/p&gt;
&lt;p&gt;在服务器上使用UFW的时候需要具备&lt;code&gt;sudo&lt;/code&gt;权限&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
      <category term="ufw" scheme="yuluo-ding.github.io/tags/ufw/"/>
    
  </entry>
  
  <entry>
    <title>解决ln -s 软链接的提示错误</title>
    <link href="yuluo-ding.github.io/2020/12/08/%E8%A7%A3%E5%86%B3ln-s-%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8F%90%E7%A4%BA%E9%94%99%E8%AF%AF/"/>
    <id>yuluo-ding.github.io/2020/12/08/解决ln-s-软链接的提示错误/</id>
    <published>2020-12-08T09:38:51.000Z</published>
    <updated>2020-12-08T09:40:46.828Z</updated>
    
    <content type="html"><![CDATA[<p>在使用<code>ln -s</code>的时候，会提示<code>Too many levels of symbolic links</code>，</p><p>这个一般是由于使用的是相对路径，改成绝对路径即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/nginx/sites-available/default //etc/nginx/sites-enabled</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用&lt;code&gt;ln -s&lt;/code&gt;的时候，会提示&lt;code&gt;Too many levels of symbolic links&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;这个一般是由于使用的是相对路径，改成绝对路径即可：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ln -s /etc/nginx/sites-available/default //etc/nginx/sites-enabled&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="yuluo-ding.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Open GApps 的不同版本</title>
    <link href="yuluo-ding.github.io/2020/09/13/Open-GApps-%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC/"/>
    <id>yuluo-ding.github.io/2020/09/13/Open-GApps-的不同版本/</id>
    <published>2020-09-13T12:02:29.000Z</published>
    <updated>2020-09-13T12:11:57.666Z</updated>
    
    <content type="html"><![CDATA[<p>虽然现在刷机的人群比之前少了很多，但是由于各种原因还是需要刷机的。</p><p>其中绝大部分还是需要GMS的服务，也就有了<a href="https://opengapps.org/">opengapps</a>，但是官网有各种版本，每个版本的还是有区别。</p><a id="more"></a><p>OpenGApps有几个不同的版本，super、stock、full、mini、micro、nano、pico，很多人不知道差别是什么，这里说明一下</p><ul><li><strong>Aroma</strong></li></ul><p>与 <code>super</code> 版所包含的 GApps 相同，但是在 Recovery 中引入了图形化界面，可以自行选择安装哪些 GApps</p><ul><li><strong>super</strong></li></ul><p>包含了所有 GApps ，像韩语日语中文拼音中文注音输入法等。（请注意：如果你是用的是基于原生的 ROM ，本版本会替换相机，通讯录等等所有有关应用）。体积1G左右，如果System分区剩余空间不够，就会刷入失败。</p><ul><li><strong>stock</strong></li></ul><p>类似于 Google Pixel 出厂内置的 GApps ，相比 super 版少了其他语种的输入法以及 Google 地球等。（请注意：如果你是用的是基于原生的 ROM ，本版本会替换相机，通讯录等等所有有关应用）。体积820M~840M左右，如果System分区剩余空间不够，就会刷入失败。</p><ul><li><strong>full</strong></li></ul><p>与 stock 版所包含的内容相同，但此版本不会替换手机原本的应用。体积670~690M左右，如果System分区剩余空间不够，就会刷入失败。</p><ul><li><strong>mini</strong></li></ul><p>包含基础的 Google 服务框架，以及一些影响力较大的 GApps ，相比 full 版去掉了 Docs 等应用。体积370M~390M左右，如果System分区剩余空间不够，就会刷入失败。</p><ul><li><strong>micro</strong></li></ul><p>包含基础的 Google 服务框架和 Gmail 等常见 GApps。体积190~210M左右，如果System分区剩余空间不够，就会刷入失败。</p><ul><li><strong>nano</strong></li></ul><p>包含基础的 Google 服务框架，但不会有其他 不必要的 GApps。体积160M~180M左右，如果System分区剩余空间不够，就会刷入失败。</p><ul><li><strong>pico</strong></li></ul><p>包含最迷你的 Google 服务框架，但由于框架并非完整，部分 GApps 可能无法运行。体积110~120M左右，如果System分区剩余空间不够，就会刷入失败。</p><p>以上关于体积的描述，指的是arm64设备。第三方原生ROM的System空间会更大一点，但仍需谨慎选择Super、Stock和full版本版本。因此，选择谷歌服务包的版本不能任性，要量力而为。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然现在刷机的人群比之前少了很多，但是由于各种原因还是需要刷机的。&lt;/p&gt;
&lt;p&gt;其中绝大部分还是需要GMS的服务，也就有了&lt;a href=&quot;https://opengapps.org/&quot;&gt;opengapps&lt;/a&gt;，但是官网有各种版本，每个版本的还是有区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="yuluo-ding.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="yuluo-ding.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>原生Android 去除叉号</title>
    <link href="yuluo-ding.github.io/2020/08/10/%E5%8E%9F%E7%94%9FAndroid-%E5%8E%BB%E9%99%A4%E5%8F%89%E5%8F%B7/"/>
    <id>yuluo-ding.github.io/2020/08/10/原生Android-去除叉号/</id>
    <published>2020-08-10T07:35:14.000Z</published>
    <updated>2020-08-10T07:38:22.893Z</updated>
    
    <content type="html"><![CDATA[<p>Android 5.0 引入的一种检测网络是否正常连接的机制，通过 HTTP 返回的状态码是否是 204 来判断是否成功，如果访问得到了 200，那你就可能处在一个需要登录验证才能上网的环境里，比如说校园网，再比如说一些酒店提供的客户才能免费使用的 Wi-Fi（其实是通过 DNS 劫持实现的），如果连接超时（根本就连接不上）就在 Wi-Fi 图标和信号图标上加一个标志，Android 5 和 Android 6 是叹号，Android 7 改成一个叉了。只不过默认访问的是谷歌自家的验证服务器，然而 Google 是被墙掉了，导致 Android 没有办法正确评估网络。所以，系统每隔一定时间都会重新尝试连接，就在不知不觉中消耗了数据流量。更恐怖的就是 Android 认为在 Wi-Fi 下无法连接互联网，就让联网的程序通通走流量…</p><a id="more"></a><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>利用ADB直接修改命令，前提是手机开启开发者选项</p><h3 id="Android-5-0-6-0"><a href="#Android-5-0-6-0" class="headerlink" title="Android 5.0 - 6.0"></a>Android 5.0 - 6.0</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除地址就可以恢复默认的谷歌服务器</span></span><br><span class="line">adb shell settings delete global captive_portal_server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置一个可用地址</span></span><br><span class="line">adb shell settings put global captive_portal_server http://developers.google.cn/generate_204</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询当前地址</span></span><br><span class="line">adb shell settings get global captive_portal_server</span><br></pre></td></tr></table></figure><h3 id="Android-7-0-Android-10-0"><a href="#Android-7-0-Android-10-0" class="headerlink" title="Android 7.0 - Android 10.0"></a>Android 7.0 - Android 10.0</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除（删除默认用HTTPS）</span></span><br><span class="line">adb shell settings delete global captive_portal_https_url</span><br><span class="line">adb shell settings delete global captive_portal_http_url</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置一个可用地址</span></span><br><span class="line">adb shell settings put global captive_portal_http_url http://developers.google.cn/generate_204</span><br><span class="line">adb shell settings put global captive_portal_https_url https://developers.google.cn/generate_204</span><br></pre></td></tr></table></figure><p>以上执行完成之后，都需要开启一下飞机模式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 5.0 引入的一种检测网络是否正常连接的机制，通过 HTTP 返回的状态码是否是 204 来判断是否成功，如果访问得到了 200，那你就可能处在一个需要登录验证才能上网的环境里，比如说校园网，再比如说一些酒店提供的客户才能免费使用的 Wi-Fi（其实是通过 DNS 劫持实现的），如果连接超时（根本就连接不上）就在 Wi-Fi 图标和信号图标上加一个标志，Android 5 和 Android 6 是叹号，Android 7 改成一个叉了。只不过默认访问的是谷歌自家的验证服务器，然而 Google 是被墙掉了，导致 Android 没有办法正确评估网络。所以，系统每隔一定时间都会重新尝试连接，就在不知不觉中消耗了数据流量。更恐怖的就是 Android 认为在 Wi-Fi 下无法连接互联网，就让联网的程序通通走流量…&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="yuluo-ding.github.io/categories/Android/"/>
    
    
      <category term="叉号" scheme="yuluo-ding.github.io/tags/%E5%8F%89%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python 创建XML文件</title>
    <link href="yuluo-ding.github.io/2020/04/18/Python%E5%88%9B%E5%BB%BAXML%E6%96%87%E4%BB%B6/"/>
    <id>yuluo-ding.github.io/2020/04/18/Python创建XML文件/</id>
    <published>2020-04-18T15:13:28.000Z</published>
    <updated>2020-04-18T15:39:41.775Z</updated>
    
    <content type="html"><![CDATA[<p>​        可扩展标记语言（英语：Extensible Markup Language，简称：XML）是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，既可以选择国际通用的标记语言，比如HTML，也可以使用像XML这样由相关人士自由决定的标记语言，这就是语言的可扩展性。XML是从标准通用标记语言（SGML）中简化修改出来的。它主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等。</p><p>​        Python 也可以创建XML格式的文件，并且有以下集中方法。</p><a id="more"></a><ol><li><p>创建的方法一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="comment"># 创建根节点</span></span><br><span class="line">root = ET.Element(<span class="string">"fm"</span>)</span><br><span class="line"><span class="comment"># 创建第一个节点</span></span><br><span class="line">s1 = root.makeelement(<span class="string">'s'</span>, &#123;<span class="string">'name'</span>: <span class="string">'g1'</span>&#125;)</span><br><span class="line"><span class="comment"># 创建第二个节点</span></span><br><span class="line">s2 = root.makeelement(<span class="string">'s'</span>, &#123;<span class="string">"name"</span>: <span class="string">'g2'</span>&#125;)</span><br><span class="line"><span class="comment"># 在第一个节点创建两个子节点</span></span><br><span class="line">ss1 = s1.makeelement(<span class="string">'ss'</span>, &#123;<span class="string">'name'</span>: <span class="string">'g11'</span>&#125;)</span><br><span class="line">ss2 = s1.makeelement(<span class="string">'ss'</span>, &#123;<span class="string">'name'</span>: <span class="string">'g12'</span>&#125;)</span><br><span class="line">s1.append(ss1)</span><br><span class="line">s1.append(ss2)</span><br><span class="line"><span class="comment"># 把子节点添加到根节点中</span></span><br><span class="line">root.append(s1)</span><br><span class="line">root.append(s1)</span><br><span class="line">tree = ET.ElementTree(root)</span><br><span class="line">tree.write(<span class="string">'oooo.xml'</span>, encoding=<span class="string">'utf-8'</span>, short_empty_elements=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li><li><p>创建的方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="comment"># 创建根节点</span></span><br><span class="line">root = ET.Element(<span class="string">"fm"</span>)</span><br><span class="line"><span class="comment"># 创建第一个节点</span></span><br><span class="line">s1 = ET.SubElement(root, <span class="string">"s"</span>, attrib=&#123;<span class="string">'name'</span>: <span class="string">'g1'</span>&#125;)</span><br><span class="line"><span class="comment"># 创建第二个节点</span></span><br><span class="line">s2 = ET.SubElement(root, <span class="string">"s"</span>, attrib=&#123;<span class="string">"name"</span>: <span class="string">"g2"</span>&#125;)</span><br><span class="line"><span class="comment"># 在第一个节点中创建两个子节点</span></span><br><span class="line">ss1 = ET.SubElement(s1, <span class="string">"age"</span>, attrib=&#123;<span class="string">'name'</span>: <span class="string">'g11'</span>&#125;)</span><br><span class="line">ss1.text = <span class="string">'txt'</span></span><br><span class="line">ss2 = ET.SubElement(s1, <span class="string">"age"</span>, attrib=&#123;<span class="string">'name'</span>: <span class="string">'g12'</span>&#125;)</span><br><span class="line">ss2.text = <span class="string">'sxs'</span></span><br><span class="line">et = ET.ElementTree(root)  <span class="comment">#生成文档对象</span></span><br><span class="line">et.write(<span class="string">"test.xml"</span>, encoding=<span class="string">"utf-8"</span>, xml_declaration=<span class="literal">True</span>, short_empty_elements=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        可扩展标记语言（英语：Extensible Markup Language，简称：XML）是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，既可以选择国际通用的标记语言，比如HTML，也可以使用像XML这样由相关人士自由决定的标记语言，这就是语言的可扩展性。XML是从标准通用标记语言（SGML）中简化修改出来的。它主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等。&lt;/p&gt;
&lt;p&gt;​        Python 也可以创建XML格式的文件，并且有以下集中方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
      <category term="XML" scheme="yuluo-ding.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Python格式化xml文件</title>
    <link href="yuluo-ding.github.io/2020/03/15/Python%E6%A0%BC%E5%BC%8F%E5%8C%96xml%E6%96%87%E4%BB%B6/"/>
    <id>yuluo-ding.github.io/2020/03/15/Python格式化xml文件/</id>
    <published>2020-03-15T14:55:50.000Z</published>
    <updated>2020-03-15T15:10:55.194Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Python构建XML文件的时候，默认是没有缩减的。</p><p>发现BeautifulSoup自带自动缩减</p><p>方法如下：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">bs = BeautifulSoup(open(tmp_file), <span class="string">'xml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(bs.prettify())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Python构建XML文件的时候，默认是没有缩减的。&lt;/p&gt;
&lt;p&gt;发现BeautifulSoup自带自动缩减&lt;/p&gt;
&lt;p&gt;方法如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
      <category term="xml" scheme="yuluo-ding.github.io/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>Python 格式化时间</title>
    <link href="yuluo-ding.github.io/2020/03/11/Python-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/"/>
    <id>yuluo-ding.github.io/2020/03/11/Python-格式化时间/</id>
    <published>2020-03-11T07:33:54.000Z</published>
    <updated>2020-03-11T07:51:48.456Z</updated>
    
    <content type="html"><![CDATA[<p>我们日常可能需要显示时间，在Python 中，一般可以使用自带的<code>datetime</code>模块。</p><p>基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">print(datetime.datetime.now())</span><br></pre></td></tr></table></figure><p>但是这个输出的是固定格式的微秒，在需要自定义的时候，还得格式化这个输出。</p><a id="more"></a><p>格式化参数：<strong>strftime</strong></p><p>使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datetime.datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure><p>剩下的其余参数如下：</p><ul><li>%y 两位数的年份表示</li><li>%Y 四位数的年份表示</li><li>%m 月份</li><li>%d 月内中的一天</li><li>%H 24小时制小时数</li><li>%I 12小时制小时数</li><li>%M 分钟数</li><li>%S 秒</li><li>%a 本地简化星期名称</li><li>%A 本地完整星期名称</li><li>%b 本地简化的月份名称</li><li>%B 本地完整的月份名称</li><li>%c 本地相应的日期表示和时间表示</li><li>%j 年内的一天</li><li>%p 本地A.M.或P.M.的等价符</li><li>%U 一年中的星期数星期天为星期的开始</li><li>%w 星期，星期天为星期的开始</li><li>%W 一年中的星期数星期一为星期的开始</li><li>%x 本地相应的日期表示</li><li>%X 本地相应的时间表示</li><li>%Z 当前时区的名称</li><li>%% %号本身</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们日常可能需要显示时间，在Python 中，一般可以使用自带的&lt;code&gt;datetime&lt;/code&gt;模块。&lt;/p&gt;
&lt;p&gt;基本语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; datetime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(datetime.datetime.now())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但是这个输出的是固定格式的微秒，在需要自定义的时候，还得格式化这个输出。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
      <category term="格式化时间" scheme="yuluo-ding.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>如何在Linux 中优先使用IPV 4</title>
    <link href="yuluo-ding.github.io/2020/03/05/%E5%A6%82%E4%BD%95%E5%9C%A8Linux-%E4%B8%AD%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8IPV-4/"/>
    <id>yuluo-ding.github.io/2020/03/05/如何在Linux-中优先使用IPV-4/</id>
    <published>2020-03-05T05:33:27.000Z</published>
    <updated>2020-03-05T05:38:22.803Z</updated>
    
    <content type="html"><![CDATA[<p>使用VPS 的时候，很多厂商默认网络链接使用IPV 6，而不是IPV 4。在实际使用中会出现下载数据问错的情况，所以可以更改设置，让它优先使用IPV 4，而不是禁用IPV 6。</p><p>两种情况</p><a id="more"></a><h5 id="Debian系："><a href="#Debian系：" class="headerlink" title="Debian系："></a>Debian系：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gai.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#把precedence ::ffff:0:0/96 100 取消注释</span></span><br></pre></td></tr></table></figure><h5 id="Red系："><a href="#Red系：" class="headerlink" title="Red系："></a>Red系：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gai.conf</span><br><span class="line"><span class="comment"># 添加如下内容</span></span><br><span class="line"></span><br><span class="line">label       ::1/128        0</span><br><span class="line">label       ::/0           1</span><br><span class="line">label       2002::/16      2</span><br><span class="line">label       ::/96          3</span><br><span class="line">label       ::ffff:0:0/96  4</span><br><span class="line">precedence  ::1/128        50</span><br><span class="line">precedence  ::/0           40</span><br><span class="line">precedence  2002::/16      30</span><br><span class="line">precedence  ::/96          20</span><br><span class="line">precedence  ::ffff:0:0/96  100</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用VPS 的时候，很多厂商默认网络链接使用IPV 6，而不是IPV 4。在实际使用中会出现下载数据问错的情况，所以可以更改设置，让它优先使用IPV 4，而不是禁用IPV 6。&lt;/p&gt;
&lt;p&gt;两种情况&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
      <category term="IPV4" scheme="yuluo-ding.github.io/tags/IPV4/"/>
    
  </entry>
  
  <entry>
    <title>SSH 连接服务器报错：ssh_exchange_identification: Connection closed by remote host</title>
    <link href="yuluo-ding.github.io/2020/02/27/SSH-%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%A5%E9%94%99%EF%BC%9Assh-exchange-identification-Connection-closed-by-remote-host/"/>
    <id>yuluo-ding.github.io/2020/02/27/SSH-连接服务器报错：ssh-exchange-identification-Connection-closed-by-remote-host/</id>
    <published>2020-02-27T02:59:10.000Z</published>
    <updated>2020-03-14T15:05:37.584Z</updated>
    
    <content type="html"><![CDATA[<p>今天尝试连接自己服务器的时候，SSH无法连接上去，并且提示：</p><p><code>ssh_exchange_identification: Connection closed by remote host</code></p><p>经过查询得知是因为SSH连接数量的问题。</p><a id="more"></a><ol><li><p>通过服务商的VNC管理程序，进入服务器</p></li><li><p>编辑<code>sshd_config</code>的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后把MaxSessions启用，并且后面的数字改成50</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存</span></span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li><p>重连即可。</p></li></ol><p>PS：如果发现还是无法连接，检查一下是否Surge开启了增强模式。关闭该模式即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天尝试连接自己服务器的时候，SSH无法连接上去，并且提示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh_exchange_identification: Connection closed by remote host&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;经过查询得知是因为SSH连接数量的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
      <category term="SSH" scheme="yuluo-ding.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>macOS下预览webp格式的图片</title>
    <link href="yuluo-ding.github.io/2020/01/24/macOS%E4%B8%8B%E9%A2%84%E8%A7%88webp%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%9B%BE%E7%89%87/"/>
    <id>yuluo-ding.github.io/2020/01/24/macOS下预览webp格式的图片/</id>
    <published>2020-01-24T15:22:57.000Z</published>
    <updated>2020-01-25T10:22:30.034Z</updated>
    
    <content type="html"><![CDATA[<p>webp格式的图片本来可以使用Chrome 查看，但是macOS自带的无法预览。</p><p>可以使用如下方法可以预览webp格式的图片。</p><p>下载安装webp-quicklook</p><a id="more"></a><ol><li>下载<a href="https://github.com/dchest/webp-quicklook/releases">webp-quicklook</a></li><li>解压得到WebP.qlgenerator</li><li>复制到<code>/Library/QuickLook</code>目录</li><li>option+右击，点击relaunch，等待Finder线程</li><li>可以使用空格点击webp格式的图片预览</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webp格式的图片本来可以使用Chrome 查看，但是macOS自带的无法预览。&lt;/p&gt;
&lt;p&gt;可以使用如下方法可以预览webp格式的图片。&lt;/p&gt;
&lt;p&gt;下载安装webp-quicklook&lt;/p&gt;
    
    </summary>
    
      <category term="mac OS" scheme="yuluo-ding.github.io/categories/mac-OS/"/>
    
    
      <category term="webp" scheme="yuluo-ding.github.io/tags/webp/"/>
    
  </entry>
  
  <entry>
    <title>解决macOS端口被占用</title>
    <link href="yuluo-ding.github.io/2019/12/26/%E8%A7%A3%E5%86%B3macOS%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/"/>
    <id>yuluo-ding.github.io/2019/12/26/解决macOS端口被占用/</id>
    <published>2019-12-26T15:18:54.000Z</published>
    <updated>2019-12-27T07:11:09.618Z</updated>
    
    <content type="html"><![CDATA[<p>在部署和测试hexo的时候，经常出现一下提示：</p><p><code>Error: listen EADDRINUSE: address already in use :::4000</code></p><p>这是说明4000端口呗占用了，之前讲了Windows下怎么解决，这次说明下macOS下怎么解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i:port # port为对应的端口号</span><br></pre></td></tr></table></figure><a id="more"></a><p>之后出现如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMMAND   PID  USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">node    10906 username   42u  IPv6 0xcd611b6cd0d363df      0t0  TCP *:terabase (LISTEN)</span><br></pre></td></tr></table></figure><p>找到PID，然后杀掉该进程就可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kill -9 PID #上面显示的PID</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在部署和测试hexo的时候，经常出现一下提示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Error: listen EADDRINUSE: address already in use :::4000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是说明4000端口呗占用了，之前讲了Windows下怎么解决，这次说明下macOS下怎么解决&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo lsof -i:port # port为对应的端口号&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="mac OS" scheme="yuluo-ding.github.io/categories/mac-OS/"/>
    
    
      <category term="macOS" scheme="yuluo-ding.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>解决1080 端口被占用</title>
    <link href="yuluo-ding.github.io/2019/12/24/%E8%A7%A3%E5%86%B31080-%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/"/>
    <id>yuluo-ding.github.io/2019/12/24/解决1080-端口被占用/</id>
    <published>2019-12-24T08:40:48.000Z</published>
    <updated>2019-12-25T07:14:43.741Z</updated>
    
    <content type="html"><![CDATA[<p>在用Windows的时候，或者一些特殊软件的时候，会提示端口被占用了，例如1080端口。</p><p>有以下几个解决办法：</p><ol><li><p>用cmd命令查看是哪个应用占用了</p><p>打开cmd，然后<code>netstat -aon|findstr &quot;1080&quot;</code>，通过最后一列得到该应用的PID，</p><p>然后根据PID找出是哪个应用，<code>tasklist|findstr PID</code> ，</p><a id="more"></a><p>最后用任务管理器kill该应用即可。</p></li><li><p>使用CurrPorts软件来查看</p><p><a href="http://www.nirsoft.net/utils/cports.html#DownloadLinks">下载地址</a></p><p>下载后直接解压运行</p><p>找到被占用的端口</p><p>右键，选择 “Close Selected TCP Connections”</p></li><li><p>修改要用的端口</p><p>例如在目录下找到<code>gui-config.json</code>文件，把其中的<code>&quot;localPort&quot; : 1080,</code>换成<code>&quot;localPort&quot; : 1090,</code>或者其余的端口，然后保存文件，重启应用。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用Windows的时候，或者一些特殊软件的时候，会提示端口被占用了，例如1080端口。&lt;/p&gt;
&lt;p&gt;有以下几个解决办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;用cmd命令查看是哪个应用占用了&lt;/p&gt;
&lt;p&gt;打开cmd，然后&lt;code&gt;netstat -aon|findstr &amp;quot;1080&amp;quot;&lt;/code&gt;，通过最后一列得到该应用的PID，&lt;/p&gt;
&lt;p&gt;然后根据PID找出是哪个应用，&lt;code&gt;tasklist|findstr PID&lt;/code&gt; ，&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="yuluo-ding.github.io/categories/Windows/"/>
    
    
      <category term="端口" scheme="yuluo-ding.github.io/tags/%E7%AB%AF%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Linux tar</title>
    <link href="yuluo-ding.github.io/2019/12/10/Linux-tar/"/>
    <id>yuluo-ding.github.io/2019/12/10/Linux-tar/</id>
    <published>2019-12-10T05:13:58.000Z</published>
    <updated>2019-12-25T07:14:33.849Z</updated>
    
    <content type="html"><![CDATA[<p>简单的说：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#压缩</span></span><br><span class="line">tar -zcvf ***.tar.gz</span><br><span class="line">tar -jcvf ***.tar.bz2</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar -zxvf ***.tar.gz</span><br><span class="line">tar -jxvf ***.tar.bz2</span><br></pre></td></tr></table></figure><a id="more"></a><p>tar [-cxtzjvfpPN] 文件与目录 ….</p><p>常用参数：</p><p>-c ：建立一个压缩文件的参数指令(create 的意思)；</p><p>-x ：解开一个压缩文件的参数指令！</p><p>-t ：查看 tarfile 里面的文件！</p><p>Ps: 特别注意，在参数的下达中， c/x/t 仅能存在一个,不可同时存在.</p><p>-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？</p><p>-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？</p><p>-v ：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！</p><p>-f ：使用档名，请留意，在 f 之后要立即接档名</p><p>-p ：使用原文件的原来属性（属性不会依据使用者而变）</p><p>-P ：可以使用绝对路径来压缩！</p><p>-N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中！</p><p>–exclude FILE：在压缩的过程中，不要将 FILE 打包！</p><p>参考 ：<a href="https://www.cnblogs.com/52linux/archive/2012/03/04/2379738.html"><a href="https://www.cnblogs.com/52linux/archive/2012/03/04/2379738.html">linux tar (打包.压缩.解压缩)命令说明 | tar如何解压文件到指定的目录？</a></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的说：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#压缩&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -zcvf ***.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -jcvf ***.tar.bz2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#解压&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf ***.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -jxvf ***.tar.bz2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
      <category term="tar" scheme="yuluo-ding.github.io/tags/tar/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 ping baidu.com 报错name or service not know</title>
    <link href="yuluo-ding.github.io/2019/12/03/CentOS-7-ping-baidu-com-%E6%8A%A5%E9%94%99name-or-service-not-know/"/>
    <id>yuluo-ding.github.io/2019/12/03/CentOS-7-ping-baidu-com-报错name-or-service-not-know/</id>
    <published>2019-12-03T08:15:41.000Z</published>
    <updated>2019-12-25T07:14:53.159Z</updated>
    
    <content type="html"><![CDATA[<p>在用 VirtualBox 安装了CentOS 7 的虚拟机之后，尝试测试用<code>ping baidu.com</code>来测试网络的连接性，提示<code>name or service not know</code>这个错误，解决办法如下：</p><ol><li>首先在<code>/etc/sysonfit/network-scripts</code>的路径下找到网卡的配置文件</li><li>用vi编辑配置文件，例如<code>vi ifcfg-eth0</code>，把其中的<code>ONBOOT=NO</code>改成<code>ONBOOT=yes</code></li><li>重启网卡<code>systemctl restart network</code></li></ol><a id="more"></a><p>如果以上还不行，则按照如下步骤：</p><ol><li><p>添加DNS服务器：<code>vi /etc/resolv.conf</code></p></li><li><p>添加<code>nameserver 114.114.114.114</code></p></li><li><p>保存该配置文件，重启网络服务<code>systemctl restart network</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用 VirtualBox 安装了CentOS 7 的虚拟机之后，尝试测试用&lt;code&gt;ping baidu.com&lt;/code&gt;来测试网络的连接性，提示&lt;code&gt;name or service not know&lt;/code&gt;这个错误，解决办法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先在&lt;code&gt;/etc/sysonfit/network-scripts&lt;/code&gt;的路径下找到网卡的配置文件&lt;/li&gt;
&lt;li&gt;用vi编辑配置文件，例如&lt;code&gt;vi ifcfg-eth0&lt;/code&gt;，把其中的&lt;code&gt;ONBOOT=NO&lt;/code&gt;改成&lt;code&gt;ONBOOT=yes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启网卡&lt;code&gt;systemctl restart network&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
      <category term="CentOS 7" scheme="yuluo-ding.github.io/tags/CentOS-7/"/>
    
  </entry>
  
  <entry>
    <title>Python 读写CSV文档</title>
    <link href="yuluo-ding.github.io/2019/10/25/Python-%E8%AF%BB%E5%86%99CSV%E6%96%87%E6%A1%A3/"/>
    <id>yuluo-ding.github.io/2019/10/25/Python-读写CSV文档/</id>
    <published>2019-10-25T06:51:46.000Z</published>
    <updated>2019-12-25T07:15:11.066Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>逗号分隔值</strong>（Comma-Separated Values，<strong>CSV</strong>，有时也称为<strong>字符分隔值</strong>，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个<a href="https://baike.baidu.com/item/字符/4768913">字符</a>序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由<a href="https://baike.baidu.com/item/字段/2885972">字段</a>组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或<a href="https://baike.baidu.com/item/制表符/7337607">制表符</a>。通常，所有记录都有完全相同的字段序列。通常都是纯文本文件。建议使用WORDPAD或是记事本来开启，再则先另存新档后用EXCEL开启，也是方法之一。</p></blockquote><a id="more"></a><p>直接创建CSV文件有两种通用的办法：</p><ol><li>直接用Excel新建文件，保存为<code>.csv</code>格式的文件即可</li><li>用文本编辑器，例如Sublime Text新建文件，保存为<code>.csv</code>格式的文件即可</li></ol><p>每一行的数据是由<code>,</code>分隔</p><h4 id="Python-处理CSV文档"><a href="#Python-处理CSV文档" class="headerlink" title="Python 处理CSV文档"></a>Python 处理CSV文档</h4><h5 id="读取CSV文档"><a href="#读取CSV文档" class="headerlink" title="读取CSV文档"></a>读取CSV文档</h5><p>利用Python 的CSV 库来处理对应的文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件至字典</span></span><br><span class="line">csv_file = open(<span class="string">"test.csv"</span>, <span class="string">"r"</span>)</span><br><span class="line">reader = csv.reader(csv_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立字典</span></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> reader:</span><br><span class="line">    result[item[<span class="number">0</span>]] = item[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">csv_file.close()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>每行数据会有一个属性：<code>line_num</code>表示行数</p><p>在遍历的时候，每一行就是一个<code>list</code>,</p><h5 id="写入CSV文档"><a href="#写入CSV文档" class="headerlink" title="写入CSV文档"></a>写入CSV文档</h5><p>要把数据写入CSV 的文件，可以直接把list格式的数据写入，但是需要注意的是要使用<code>writerow</code>，否者不会自动换行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件头，一般就是数据名</span></span><br><span class="line">fileHeader = [<span class="string">"name"</span>, <span class="string">"score"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们要写入的是以下两行数据</span></span><br><span class="line">d1 = [<span class="string">"Wang"</span>, <span class="string">"100"</span>]</span><br><span class="line">d2 = [<span class="string">"Li"</span>, <span class="string">"80"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入数据</span></span><br><span class="line">csv_file = open(<span class="string">"test.csv"</span>, <span class="string">"w"</span>)</span><br><span class="line">writer = csv.writer(csvFile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入的内容都是以列表的形式传入函数</span></span><br><span class="line">writer.writerow(fileHeader)</span><br><span class="line">writer.writerow(d1)</span><br><span class="line">writer.writerow(d1)</span><br><span class="line"></span><br><span class="line">csv_file.close()</span><br></pre></td></tr></table></figure><p>也可以直接使用<code>writerows</code>，一次性把数据放入一个list里面直接写入。</p><h5 id="DictReader"><a href="#DictReader" class="headerlink" title="DictReader"></a>DictReader</h5><p>可以直接把数据读取为字典的形式，第一行一般是文件的内容描述，自动作为字典的key值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csv_file = csv.DictReader(csv_file)</span><br></pre></td></tr></table></figure><h5 id="DictWriter"><a href="#DictWriter" class="headerlink" title="DictWriter"></a>DictWriter</h5><p>以字典的形式把数据写入文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csv_file = csv.DictWriter(csv_file, fileheader)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;逗号分隔值&lt;/strong&gt;（Comma-Separated Values，&lt;strong&gt;CSV&lt;/strong&gt;，有时也称为&lt;strong&gt;字符分隔值&lt;/strong&gt;，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个&lt;a href=&quot;https://baike.baidu.com/item/字符/4768913&quot;&gt;字符&lt;/a&gt;序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由&lt;a href=&quot;https://baike.baidu.com/item/字段/2885972&quot;&gt;字段&lt;/a&gt;组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或&lt;a href=&quot;https://baike.baidu.com/item/制表符/7337607&quot;&gt;制表符&lt;/a&gt;。通常，所有记录都有完全相同的字段序列。通常都是纯文本文件。建议使用WORDPAD或是记事本来开启，再则先另存新档后用EXCEL开启，也是方法之一。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
      <category term="CSV" scheme="yuluo-ding.github.io/tags/CSV/"/>
    
  </entry>
  
  <entry>
    <title>小米6 刷机记录</title>
    <link href="yuluo-ding.github.io/2019/10/23/%E5%B0%8F%E7%B1%B36-%E5%88%B7%E6%9C%BA%E8%AE%B0%E5%BD%95/"/>
    <id>yuluo-ding.github.io/2019/10/23/小米6-刷机记录/</id>
    <published>2019-10-23T08:45:13.000Z</published>
    <updated>2019-12-25T07:15:18.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小米6刷机记录"><a href="#小米6刷机记录" class="headerlink" title="小米6刷机记录"></a>小米6刷机记录</h3><ul><li>adb/fastboot工具：Minimal ADB and Fastboot</li><li>刷之前的MIUI为：MIUI的稳定版</li><li>TWRP：官网上小米6的3.2.1</li><li>安装完成后刷入了基于原生Android开源项目的ROM包（基于android 8.1.0）</li></ul><a id="more"></a><h3 id="准备好adb-fastboot工具"><a href="#准备好adb-fastboot工具" class="headerlink" title="准备好adb/fastboot工具"></a>准备好adb/fastboot工具</h3><p><a href="https://developer.android.com/studio/releases/platform-tools">Google官网地址</a><br><a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip">ADB和fastboot for Windows</a><br><a href="https://dl.google.com/android/repository/platform-tools-latest-darwin.zip">ADB和fastboot for macOS</a></p><h3 id="下载TWRP"><a href="#下载TWRP" class="headerlink" title="下载TWRP"></a>下载TWRP</h3><p>在<a href="http://link.zhihu.com/?target=https%3A//twrp.me/Devices/">TWRP设备列表</a>找到对应的设备，然后选择一个区域下载img文件到本地</p><h3 id="刷机步骤"><a href="#刷机步骤" class="headerlink" title="刷机步骤"></a>刷机步骤</h3><ol><li><p>保证手机已经打开USB调试模式<br> 用<code>adb devices</code>能在输出中看到设备记录就算成功</p></li><li><p>用数据线连接手机和电脑，打开终端或者进入ADB目录文件下</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash recovery twrp.img</span><br><span class="line">fastboot boot twrp.img # 此行命令可以进TWRP的recovery，但是如果没有刷ROM就重启，那么recovery就会被覆盖</span><br></pre></td></tr></table></figure></li><li><p>把ROM推送到手机中，刷ROM<br> <code>adb push *.zip /sdcard</code><br> 然后在手机中操作，先三清，然后选择该ROM刷入</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;小米6刷机记录&quot;&gt;&lt;a href=&quot;#小米6刷机记录&quot; class=&quot;headerlink&quot; title=&quot;小米6刷机记录&quot;&gt;&lt;/a&gt;小米6刷机记录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;adb/fastboot工具：Minimal ADB and Fastboot&lt;/li&gt;
&lt;li&gt;刷之前的MIUI为：MIUI的稳定版&lt;/li&gt;
&lt;li&gt;TWRP：官网上小米6的3.2.1&lt;/li&gt;
&lt;li&gt;安装完成后刷入了基于原生Android开源项目的ROM包（基于android 8.1.0）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="yuluo-ding.github.io/categories/Android/"/>
    
    
      <category term="小米 6" scheme="yuluo-ding.github.io/tags/%E5%B0%8F%E7%B1%B3-6/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 18 设置静态IP</title>
    <link href="yuluo-ding.github.io/2019/10/12/Ubuntu18-%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
    <id>yuluo-ding.github.io/2019/10/12/Ubuntu18-设置静态IP/</id>
    <published>2019-10-12T02:38:07.000Z</published>
    <updated>2019-12-25T07:15:02.721Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu 18 的网络管理程序变成了netplan，所以配置方式也跟16不一样了。</p><p>现在的网卡配置文件是：</p><p><code>/etc/netplan/50-cloud-init.yaml</code></p><p>采用了YAML的文件格式，设置静态IP的格式如下：</p><a id="more"></a><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">    <span class="attr">ethernets:</span></span><br><span class="line">        <span class="attr">enp0s3:</span></span><br><span class="line">            <span class="attr">addresses:</span> <span class="string">[192.168.1.100/24]</span></span><br><span class="line">            <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br><span class="line">            <span class="attr">dhcp6:</span> <span class="literal">no</span></span><br><span class="line">            <span class="attr">gateway4:</span>  <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">            <span class="attr">nameservers:</span></span><br><span class="line">                <span class="attr">addresses:</span> <span class="string">[8.8.8.8,</span> <span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span><span class="string">]</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>保存之后，利用<code>netplan apply</code>生效</p><p><code>ifconfig</code>查看是否是新的IP地址</p><p>PS：</p><p>基于YAML的格式要求，每一行的<code>:</code>要有空格，否则在重启的时候会报错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu 18 的网络管理程序变成了netplan，所以配置方式也跟16不一样了。&lt;/p&gt;
&lt;p&gt;现在的网卡配置文件是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/netplan/50-cloud-init.yaml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;采用了YAML的文件格式，设置静态IP的格式如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu18" scheme="yuluo-ding.github.io/tags/Ubuntu18/"/>
    
  </entry>
  
  <entry>
    <title>Linux查找并杀死多个进程</title>
    <link href="yuluo-ding.github.io/2019/09/27/Linux%E6%9F%A5%E6%89%BE%E5%B9%B6%E6%9D%80%E6%AD%BB%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B/"/>
    <id>yuluo-ding.github.io/2019/09/27/Linux查找并杀死多个进程/</id>
    <published>2019-09-27T09:27:34.000Z</published>
    <updated>2019-09-27T09:30:59.337Z</updated>
    
    <content type="html"><![CDATA[<p><code>ps -ef|grep python|grep -v grep|cut -c 9-15|xargs kill -9</code></p><p><code>ps -ef</code>查看所有进程</p><p><code>grep python</code>塞选出含有python的进程</p><p><code>grep -v grep</code>排除最上面那个命令的进程</p><p><code>cut -c 9-15</code>是截取输入行的第9个字符到第15个字符，而这正好是进程号PID</p><p><code>xargs kill -9</code>中的xargs命令是用来把前面命令的输出结果（PID）作为“kill -9”命令的参数，并执行该命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ps -ef|grep python|grep -v grep|cut -c 9-15|xargs kill -9&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ps -ef&lt;/code&gt;查看所有进程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grep python&lt;/code&gt;塞选
      
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="yuluo-ding.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>让Chrome显示www和https</title>
    <link href="yuluo-ding.github.io/2019/09/23/%E8%AE%A9Chrome%E6%98%BE%E7%A4%BAwww%E5%92%8Chttps/"/>
    <id>yuluo-ding.github.io/2019/09/23/让Chrome显示www和https/</id>
    <published>2019-09-23T02:42:29.000Z</published>
    <updated>2019-09-23T02:46:42.385Z</updated>
    
    <content type="html"><![CDATA[<p>新版的Chrome 77又把<code>www</code>和<code>https</code>给隐藏了，日常搞事啊，恢复显示的步骤如下</p><p>在浏览器的地址栏输入以下两个命令：</p><ol><li><code>chrome://flags/#omnibox-ui-hide-steady-state-url-scheme</code>，然后选择disabled</li><li><code>chrome://flags/#omnibox-ui-hide-steady-state-url-trivial-subdomains</code>，然后选择disabled</li><li>重启Chrome浏览器</li></ol><p>重新打开网站，应该就能恢复了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新版的Chrome 77又把&lt;code&gt;www&lt;/code&gt;和&lt;code&gt;https&lt;/code&gt;给隐藏了，日常搞事啊，恢复显示的步骤如下&lt;/p&gt;
&lt;p&gt;在浏览器的地址栏输入以下两个命令：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;chrome://flags/#omnibox
      
    
    </summary>
    
      <category term="Google" scheme="yuluo-ding.github.io/categories/Google/"/>
    
    
      <category term="Chrome" scheme="yuluo-ding.github.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>在Android Pie中安装Xposed</title>
    <link href="yuluo-ding.github.io/2019/09/10/%E5%9C%A8Android-Pie%E4%B8%AD%E5%AE%89%E8%A3%85Xposed/"/>
    <id>yuluo-ding.github.io/2019/09/10/在Android-Pie中安装Xposed/</id>
    <published>2019-09-10T05:58:06.000Z</published>
    <updated>2020-12-10T03:08:46.571Z</updated>
    
    <content type="html"><![CDATA[<p>如今重新命名的Android 10都已经发布了，但是针对Android Pie的Xpsoed官方版还是没有发布，据说作者去Apple工作去了？但是开源社区的好处就是有人能够实现同样的效果。</p><p>这个是Elder Driver开发的非官方端口，Xposed for Android Pie。它被命名为<code>EDXposed</code>， 还需要额外安装<code>Riru Core</code>，具体步骤如下。</p><a id="more"></a><ul><li>下载 <a href="https://github.com/RikkaApps/Riru/releases">Riru Core</a>压缩包，放入手机</li><li>下载 <a href="https://github.com/ElderDrivers/EdXposed/releases">EdXposed</a>压缩包，可以选择YAHFA，放入手机</li><li>下载 <a href="https://github.com/ElderDrivers/EdXposedManager/releases">EdXposedManager</a>的apk，并且安装</li></ul><p>打开<code>Magisk manager</code>， 打开多功能菜单，选择模块，然后点击添加按钮，分别刷入上文下载的两个压缩包。</p><p>重启手机激活以上两个模块，然后打开<code>EdXposed Manager</code>，看到已经激活了。</p><p>如果没有，请卸载，重新尝试以上步骤。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如今重新命名的Android 10都已经发布了，但是针对Android Pie的Xpsoed官方版还是没有发布，据说作者去Apple工作去了？但是开源社区的好处就是有人能够实现同样的效果。&lt;/p&gt;
&lt;p&gt;这个是Elder Driver开发的非官方端口，Xposed for Android Pie。它被命名为&lt;code&gt;EDXposed&lt;/code&gt;， 还需要额外安装&lt;code&gt;Riru Core&lt;/code&gt;，具体步骤如下。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="yuluo-ding.github.io/categories/Android/"/>
    
    
      <category term="Xposed" scheme="yuluo-ding.github.io/tags/Xposed/"/>
    
  </entry>
  
</feed>

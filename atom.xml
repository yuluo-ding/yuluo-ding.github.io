<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yuluo</title>
  
  <subtitle>The home of yuluo!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="yuluo-ding.github.io/"/>
  <updated>2018-11-05T15:02:55.301Z</updated>
  <id>yuluo-ding.github.io/</id>
  
  <author>
    <name>Luo Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android各国分发渠道</title>
    <link href="yuluo-ding.github.io/2018/11/05/Android%E5%90%84%E5%9B%BD%E5%88%86%E5%8F%91%E6%B8%A0%E9%81%93/"/>
    <id>yuluo-ding.github.io/2018/11/05/Android各国分发渠道/</id>
    <published>2018-11-05T14:57:55.000Z</published>
    <updated>2018-11-05T15:02:55.301Z</updated>
    
    <content type="html"><![CDATA[<p>绝大多数国家，主要市场是Google Play，部分国家有一些第三方市场。<br>通用的商店：Aptoide、Mobango、Mobogenie</p><p>美洲</p><p>美国： Google Play （主要）<br>​             Amazon Appstore<br>​             GetJar<br>​             AppBrain<br>​             SlideME (slide Me会在超过两千万的不同的OEM APP STORE上预安装)</p><p>巴西： 1.Mobo Robo market MoboRobo - The Android Smartphone PC Manager. Free for Life!<br>​             2.F-Droid F-Droid | Free and Open Source Android App Repository</p><p>墨西哥 Google Play<br>阿根廷 Google Play<br>哥伦比亚 Google Play<br>加拿大 Google Play</p><p>亚洲</p><p>印度 Google Play<br>泰国 Google Play<br>越南 越南大部分Market并不提供自己的下载，而是直接指向Google Play链接</p><p>印尼： 1. Jalan Tikus<br>​             2. Gudang Aplikasi<br>​             3.TemanDev<br>​             4. WePlay</p><p>韩国：SK T-Store,<br>​            Naver NStore,<br>​            APPZIL,olleh Market<br>​            Sumsang Apps会在超过1亿的Galaxy智能机上预安装</p><p>欧洲</p><p>俄罗斯： 1.Yandex: Yandex.Store<br>​                 2. Androidpit: Новости, игры и приложения для Android<br>​                 3. Все для Андроид. Cкачать лучшие приложения для Андроид</p><p>意大利： 1.Androidpit Tutte le applicazioni per Android AndroidPIT<br>2.Vshare vShare Android Market: Free download Android Apps &amp; Best Android Apk games for Android tablet and mobilephones<br>3.appbrain AppBrain App Market (Android)<br>4.softonic . <a href="http://best-apps-market.softonic.it/android" target="_blank" rel="noopener">http://best-apps-market.softonic.it/android</a></p><p>英国 Google Play</p><p>德国： 1.avira app store Avira AppStore<br>2.9 apps Free Android Apps Download<br>3.Apk4fun APK4Fun - Download APK for Fun Android Apps &amp; Games<br>4.Androidpit Alle Android-Apps &amp; Android-Spiele aus dem Google Play Store AndroidPIT</p><ol start="5"><li>goodereader Android App Store &amp; Blackberry App Store</li></ol><p>芬兰 Google Play</p><p>法国： 1. 1 mobile market 1Mobile Market<br>2.androidpit Tout sur Android: Nouveautés, applications, tests, astuces, forum &amp; communauté</p><p>波兰 Google Play<br>土耳其 Google Play<br>西班牙 Google Play</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;绝大多数国家，主要市场是Google Play，部分国家有一些第三方市场。&lt;br&gt;通用的商店：Aptoide、Mobango、Mobogenie&lt;/p&gt;
&lt;p&gt;美洲&lt;/p&gt;
&lt;p&gt;美国： Google Play （主要）&lt;br&gt;​             Amazon Ap
      
    
    </summary>
    
      <category term="Life" scheme="yuluo-ding.github.io/categories/Life/"/>
    
    
      <category term="Android" scheme="yuluo-ding.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>终端命令行计算文件的散列值</title>
    <link href="yuluo-ding.github.io/2018/11/04/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%A1%E7%AE%97%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%A3%E5%88%97%E5%80%BC/"/>
    <id>yuluo-ding.github.io/2018/11/04/终端命令行计算文件的散列值/</id>
    <published>2018-11-04T15:07:11.000Z</published>
    <updated>2018-11-04T15:10:09.118Z</updated>
    
    <content type="html"><![CDATA[<p>计算 MD5 校验和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5 filename</span><br></pre></td></tr></table></figure><h4 id="计算_SHA-1_校验和">计算 SHA-1 校验和</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shasum -a 1 filename</span><br></pre></td></tr></table></figure><h4 id="计算_SHA-256_校验和">计算 SHA-256 校验和</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shasum -a 256 filename</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算 MD5 校验和&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;co
      
    
    </summary>
    
      <category term="mac OS" scheme="yuluo-ding.github.io/categories/mac-OS/"/>
    
    
      <category term="terminal" scheme="yuluo-ding.github.io/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Python 两个list 求交集，并集，差集</title>
    <link href="yuluo-ding.github.io/2018/09/14/Python-%E4%B8%A4%E4%B8%AAlist-%E6%B1%82%E4%BA%A4%E9%9B%86%EF%BC%8C%E5%B9%B6%E9%9B%86%EF%BC%8C%E5%B7%AE%E9%9B%86/"/>
    <id>yuluo-ding.github.io/2018/09/14/Python-两个list-求交集，并集，差集/</id>
    <published>2018-09-14T02:34:00.000Z</published>
    <updated>2018-09-14T02:36:22.966Z</updated>
    
    <content type="html"><![CDATA[<p>在python中，分别求两个list 的交集，并集与差集，怎么实现比较方便呢？<br>除了两个for 循环, 还有其余的更方便的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diff</span><span class="params">(listA,listB)</span>:</span></span><br><span class="line">    <span class="comment">#求交集的两种方式</span></span><br><span class="line">    retA = [i <span class="keyword">for</span> i <span class="keyword">in</span> listA <span class="keyword">if</span> i <span class="keyword">in</span> listB]</span><br><span class="line">    retB = list(set(listA).intersection(set(listB)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"retA is: "</span>,retA</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"retB is: "</span>,retB</span><br><span class="line"></span><br><span class="line">    <span class="comment">#求并集</span></span><br><span class="line">    retC = list(set(listA).union(set(listB)))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"retC1 is: "</span>,retC</span><br><span class="line"></span><br><span class="line">    <span class="comment">#求差集，在B中但不在A中</span></span><br><span class="line">    retD = list(set(listB).difference(set(listA)))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"retD is: "</span>,retD</span><br><span class="line"></span><br><span class="line">    retE = [i <span class="keyword">for</span> i <span class="keyword">in</span> listB <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> listA]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"retE is: "</span>,retE</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    listA = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    listB = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">    diff(listA,listB)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>大体上是两种思路：<br>1.使用列表解析式. 列表解析式一般来说比循环更快.<br>2.将list转成set以后，使用set的各种方法去处理.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在python中，分别求两个list 的交集，并集与差集，怎么实现比较方便呢？&lt;br&gt;除了两个for 循环, 还有其余的更方便的方法&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
      <category term="list" scheme="yuluo-ding.github.io/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的文件系统路径-pathlib</title>
    <link href="yuluo-ding.github.io/2018/09/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84-pathlib/"/>
    <id>yuluo-ding.github.io/2018/09/11/面向对象的文件系统路径-pathlib/</id>
    <published>2018-09-11T08:16:57.000Z</published>
    <updated>2018-09-16T14:13:32.067Z</updated>
    
    <content type="html"><![CDATA[<p>该模块提供表示文件系统路径的类，其语义适用于不同的操作系统。 pathlib类在纯路径之间划分，纯路径提供纯粹的计算操作而没有I / O，以及具体路径，它继承纯路径但也提供I / O操作。</p><p><img src="https://i.loli.net/2018/09/11/5b977c128ed97.png" alt=""></p><p>如果你之前从未使用过此模块，或者只是不确定哪个类适合你的任务，那么Path很可能就是你所需要的。 为运行代码的平台提供了实例化的具体路径。</p><p>纯路径在某些特殊情况下很有用; 例如：</p><ol><li>如果要在Unix计算机上操作Windows路径（反之亦然）。 在Unix上运行时无法实例化WindowsPath，但可以实例化PureWindowsPath。</li><li>你希望确保你的代码仅操作路径而不实际访问操作系统。 在这种情况下，实例化其中一个纯类可能很有用，因为那些只是没有任何操作系统访问操作。</li></ol><h3 id="基础使用">基础使用</h3><p>导入主类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br></pre></td></tr></table></figure><p> 列出子目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Path(<span class="string">'.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> x.is_dir()]</span><br><span class="line">[PosixPath(<span class="string">'.hg'</span>), PosixPath(<span class="string">'docs'</span>), PosixPath(<span class="string">'dist'</span>),</span><br><span class="line"> PosixPath(<span class="string">'__pycache__'</span>), PosixPath(<span class="string">'build'</span>)]</span><br></pre></td></tr></table></figure><p>在此目录树中列出Python源文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(p.glob(<span class="string">'**/*.py'</span>))</span><br><span class="line">[PosixPath(<span class="string">'test_pathlib.py'</span>), PosixPath(<span class="string">'setup.py'</span>),</span><br><span class="line"> PosixPath(<span class="string">'pathlib.py'</span>), PosixPath(<span class="string">'docs/conf.py'</span>),PosixPath(<span class="string">'build/lib/pathlib.py'</span>)]</span><br></pre></td></tr></table></figure><p>在根目录插入目录树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Path(<span class="string">'/etc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = p / <span class="string">'init.d'</span> / <span class="string">'reboot'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">PosixPath(<span class="string">'/etc/init.d/reboot'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.resolve()</span><br><span class="line">PosixPath(<span class="string">'/etc/rc.d/init.d/halt'</span>)</span><br></pre></td></tr></table></figure><p>查询目录属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.exists()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.is_dir()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p> 打开一个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> q.open() <span class="keyword">as</span> f: f.readline()</span><br><span class="line">...</span><br><span class="line"><span class="string">'#!/bin/bash\n'</span></span><br></pre></td></tr></table></figure><h3 id="Pure_paths">Pure paths</h3><p><code>Pure path</code> 对象提供了实际上不访问文件系统的路径处理操作。 有三种方法可以访问这些类，我们也称之为<code>flavours</code>：</p><h5 id="class_pathlib-PurePath(*pathsegments)">class pathlib.PurePath(*pathsegments)</h5><p>表示系统路径风格的泛型类（实例化它会创建PurePosixPath或PureWindowsPath）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'setup.py'</span>)      <span class="comment"># Running on a Unix machine</span></span><br><span class="line">PurePosixPath(<span class="string">'setup.py'</span>)</span><br></pre></td></tr></table></figure><p>每个路径元素可以是一个表示路径段的字符串，一个实现操作系统的对象。返回字符串或其他路径对象的PathLike接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'foo'</span>, <span class="string">'some/path'</span>, <span class="string">'bar'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'foo/some/path/bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(Path(<span class="string">'foo'</span>), Path(<span class="string">'bar'</span>))</span><br><span class="line">PurePosixPath(<span class="string">'foo/bar'</span>)</span><br></pre></td></tr></table></figure><p>当路径记录为空, 则默认当前目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath()</span><br><span class="line">PurePosixPath(<span class="string">'.'</span>)</span><br></pre></td></tr></table></figure><p>当给出几个绝对路径时，最后一个被选为一个锚（模仿<code>os.path.join()</code>的行为)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'/etc'</span>, <span class="string">'/usr'</span>, <span class="string">'lib64'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'/usr/lib64'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:/Windows'</span>, <span class="string">'d:bar'</span>)</span><br><span class="line">PureWindowsPath(<span class="string">'d:bar'</span>)</span><br></pre></td></tr></table></figure><p>但是，在Windows路径中，更改本地根目录并不丢弃以前的驱动器设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:/Windows'</span>, <span class="string">'/Program Files'</span>)</span><br><span class="line">PureWindowsPath(<span class="string">'c:/Program Files'</span>)</span><br></pre></td></tr></table></figure><p>双斜线和单点会折叠，但双点（’..’）则不会，因为这将在符号链接面前改变一条路径的含义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'foo//bar'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'foo/bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'foo/./bar'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'foo/bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'foo/../bar'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'foo/../bar'</span>)</span><br></pre></td></tr></table></figure><p>（naïve方法将使PurePosixPath（’foo/../bar’）等同于PurePosixPath（’bar’），如果foo是指向另一个目录的符号链接，则该方法是错误的)</p><p><code>Pure path</code>对象是实现os.PathLike接口，允许在接受接口的任何地方使用它们</p><p>版本3.6中已更改：添加了对os.PathLike接口的支持。</p><h5 id="class_pathlib-PurePosixPath(*pathsegments)">class pathlib.PurePosixPath(*pathsegments)</h5><p>作为PurePath的子类，此路径样式表示非Windows文件系统路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &gt;&gt;&gt; PurePosixPath(<span class="string">'/etc'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'/etc'</span>)</span><br></pre></td></tr></table></figure><p>路径指定类似于PurePath</p><h5 id="class_pathlib-PureWindowsPath(*pathsegments)">class pathlib.PureWindowsPath(*pathsegments)</h5><p>作为PurePath的子类，此路径样式表示Windows文件系统路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:/Program Files/'</span>)</span><br><span class="line">PureWindowsPath(<span class="string">'c:/Program Files'</span>)</span><br></pre></td></tr></table></figure><p>路径指定类似于PurePath</p><p>无论运行的是哪个系统，都可以实例化所有这些类，因为它们不提供任何进行系统调用的操作</p><h4 id="一般的属性">一般的属性</h4><p>路径是不可变的和可散列的。同一种风格的路径是可比较和可排序的。这些属性尊重风格的大小写和语义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'foo'</span>) == PurePosixPath(<span class="string">'FOO'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'foo'</span>) == PureWindowsPath(<span class="string">'FOO'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'FOO'</span>) <span class="keyword">in</span> &#123; PureWindowsPath(<span class="string">'foo'</span>) &#125;</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'C:'</span>) &lt; PureWindowsPath(<span class="string">'d:'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>不同风格的路径不能比较，不能排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'foo'</span>) == PurePosixPath(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'foo'</span>) &lt; PurePosixPath(<span class="string">'foo'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'&lt;'</span> <span class="keyword">not</span> supported between instances of <span class="string">'PureWindowsPath'</span> <span class="keyword">and</span> <span class="string">'PurePosixPath'</span></span><br></pre></td></tr></table></figure><h4 id="操作">操作</h4><p>斜杠操作符帮助创建子路径, 类似<code>os.path.join()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PurePath(<span class="string">'/etc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">PurePosixPath(<span class="string">'/etc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p / <span class="string">'init.d'</span> / <span class="string">'apache2'</span></span><br><span class="line">PurePosixPath(<span class="string">'/etc/init.d/apache2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = PurePath(<span class="string">'bin'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'/usr'</span> / q</span><br><span class="line">PurePosixPath(<span class="string">'/usr/bin'</span>)</span><br></pre></td></tr></table></figure><p>路径对象可以用任何<code>os.PathLike</code>可接受的接口的地方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PurePath(<span class="string">'/etc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.fspath(p)</span><br><span class="line"><span class="string">'/etc'</span></span><br></pre></td></tr></table></figure><p>路径的字符串表示形式是原始文件系统路径本身（以本机形式，例如Windows下的反斜杠），你可以将它传递给任何将文件路径作为字符串的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PurePath(<span class="string">'/etc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(p)</span><br><span class="line"><span class="string">'/etc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PureWindowsPath(<span class="string">'c:/Program Files'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(p)</span><br><span class="line"><span class="string">'c:\\Program Files'</span></span><br></pre></td></tr></table></figure><p>类似地，在路径上调用字节会将原始文件系统路径作为字节对象提供，如os.fsencode()所编码的那样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytes(p)</span><br><span class="line"><span class="string">b'/etc'</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:只建议在Unix下调用字节。在Windows下，unicode表单是文件系统路径的规范化表示形式。</p></blockquote><h4 id="对组件的访问">对组件的访问</h4><p>若要访问路径的各个“部件”（组件），请使用以下属性</p><h5 id="PurePath-parts">PurePath.parts</h5><p>一个元组，用于访问路径的各个组件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PurePath(<span class="string">'/usr/bin/python3'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.parts</span><br><span class="line">(<span class="string">'/'</span>, <span class="string">'usr'</span>, <span class="string">'bin'</span>, <span class="string">'python3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PureWindowsPath(<span class="string">'c:/Program Files/PSF'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.parts</span><br><span class="line">(<span class="string">'c:\\'</span>, <span class="string">'Program Files'</span>, <span class="string">'PSF'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>（注意驱动器和本地根目录是如何在单个部件中重新分组的）</p></blockquote><p>UNC 分享也被认为是驱动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'//host/share/foo.txt'</span>).drive</span><br><span class="line"><span class="string">'\\\\host\\share'</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-root">PurePath.root</h5><p>一个字符串，表示（本地或全局）根目录（如果有的话）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:/Program Files/'</span>).root</span><br><span class="line"><span class="string">'\\'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:Program Files/'</span>).root</span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'/etc'</span>).root</span><br><span class="line"><span class="string">'/'</span></span><br></pre></td></tr></table></figure><p>NUC 分享也总有一个根目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'//host/share'</span>).root</span><br><span class="line"><span class="string">'\\'</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-anchor">PurePath.anchor</h5><p>驱动和根目录的连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:/Program Files/'</span>).anchor</span><br><span class="line"><span class="string">'c:\\'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:Program Files/'</span>).anchor</span><br><span class="line"><span class="string">'c:'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'/etc'</span>).anchor</span><br><span class="line"><span class="string">'/'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'//host/share'</span>).anchor</span><br><span class="line"><span class="string">'\\\\host\\share\\'</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-parents">PurePath.parents</h5><p>一个不可变序列提供对路径逻辑父级目录的访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PureWindowsPath(<span class="string">'c:/foo/bar/setup.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.parents[<span class="number">0</span>]</span><br><span class="line">PureWindowsPath(<span class="string">'c:/foo/bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.parents[<span class="number">1</span>]</span><br><span class="line">PureWindowsPath(<span class="string">'c:/foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.parents[<span class="number">2</span>]</span><br><span class="line">PureWindowsPath(<span class="string">'c:/'</span>)</span><br></pre></td></tr></table></figure><h5 id="PurePath-parent">PurePath.parent</h5><p>父级目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PurePosixPath(<span class="string">'/a/b/c/d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.parent</span><br><span class="line">PurePosixPath(<span class="string">'/a/b/c'</span>)</span><br></pre></td></tr></table></figure><p>你不能通过锚定或者一个空目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PurePosixPath(<span class="string">'/'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.parent</span><br><span class="line">PurePosixPath(<span class="string">'/'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PurePosixPath(<span class="string">'.'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.parent</span><br><span class="line">PurePosixPath(<span class="string">'.'</span>)</span><br></pre></td></tr></table></figure><h5 id="PurePath-name">PurePath.name</h5><p>一个字符串表示最终路径目录（如果有的话），不包括驱动器和根目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library/setup.py'</span>).name</span><br><span class="line"><span class="string">'setup.py'</span></span><br></pre></td></tr></table></figure><p>不考虑UNC驱动器名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'//some/share/setup.py'</span>).name</span><br><span class="line"><span class="string">'setup.py'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'//some/share'</span>).name</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-suffix">PurePath.suffix</h5><p>最终的文件扩展名(如果有的话)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library/setup.py'</span>).suffix</span><br><span class="line"><span class="string">'.py'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library.tar.gz'</span>).suffix</span><br><span class="line"><span class="string">'.gz'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library'</span>).suffix</span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-suffixes">PurePath.suffixes</h5><p>路径的扩展名的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library.tar.gar'</span>).suffixes</span><br><span class="line">[<span class="string">'.tar'</span>, <span class="string">'.gar'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library.tar.gz'</span>).suffixes</span><br><span class="line">[<span class="string">'.tar'</span>, <span class="string">'.gz'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library'</span>).suffixes</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h5 id="PurePath-stem">PurePath.stem</h5><p>最终路径的零件, 没有扩展名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library.tar.gz'</span>).stem</span><br><span class="line"><span class="string">'library.tar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library.tar'</span>).stem</span><br><span class="line"><span class="string">'library'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'my/library'</span>).stem</span><br><span class="line"><span class="string">'library'</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-as_posix()">PurePath.as_posix()</h5><p>返回带有斜杠的路径的字符串表示形式（/）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PureWindowsPath(<span class="string">'c:\\windows'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(p)</span><br><span class="line"><span class="string">'c:\\windows'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.as_posix()</span><br><span class="line"><span class="string">'c:/windows'</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-as_uri()">PurePath.as_uri()</h5><p>将路径表示为一个文件URI。如果路径不是绝对的，则引发ValueError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PurePosixPath(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.as_uri()</span><br><span class="line"><span class="string">'file:///etc/passwd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PureWindowsPath(<span class="string">'c:/Windows'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.as_uri()</span><br><span class="line"><span class="string">'file:///c:/Windows'</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-is_absolute()">PurePath.is_absolute()</h5><p>无论路径是否绝对，都返回。如果路径同时具有根和（如果允许）驱动器，则认为它是绝对路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'/a/b'</span>).is_absolute()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'a/b'</span>).is_absolute()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:/a/b'</span>).is_absolute()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'/a/b'</span>).is_absolute()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:'</span>).is_absolute()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'//some/share'</span>).is_absolute()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-is_reserved()">PurePath.is_reserved()</h5><p>对于PureWindowsPath，如果路径被认为是在Windows下保留的，则返回True，否则返回False 使用PurePosixPath时，False总是返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'nul'</span>).is_reserved()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'nul'</span>).is_reserved()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>保留路径上的文件系统调用可能会神秘地失败或产生意外的结果。</p><h5 id="PurePath-joinpath(*other)">PurePath.joinpath(*<em>other</em>)</h5><p>调用此方法相当于依次将路径与其他参数组合在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'/etc'</span>).joinpath(<span class="string">'passwd'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'/etc'</span>).joinpath(PurePosixPath(<span class="string">'passwd'</span>))</span><br><span class="line">PurePosixPath(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePosixPath(<span class="string">'/etc'</span>).joinpath(<span class="string">'init.d'</span>, <span class="string">'apache2'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'/etc/init.d/apache2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'c:'</span>).joinpath(<span class="string">'/Program Files'</span>)</span><br><span class="line">PureWindowsPath(<span class="string">'c:/Program Files'</span>)</span><br></pre></td></tr></table></figure><h5 id="PurePath-match(pattern)">PurePath.match(<em>pattern</em>)</h5><p>将此路径与提供的全局样式模式匹配。如果匹配成功，则返回真。否则为假。</p><p>如果模式是相对的，路径可以是相对的，也可以是绝对的，匹配可以从右边进行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'a/b.py'</span>).match(<span class="string">'*.py'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'/a/b/c.py'</span>).match(<span class="string">'b/*.py'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'/a/b/c.py'</span>).match(<span class="string">'a/*.py'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>如果模式是绝对的，那么路径必须是绝对的，并且整个路径必须匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'/a.py'</span>).match(<span class="string">'/*.py'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PurePath(<span class="string">'a/b.py'</span>).match(<span class="string">'/*.py'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>和其他方法一样，个案敏感性是观察到的，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PureWindowsPath(<span class="string">'b.py'</span>).match(<span class="string">'*.PY'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-relative_to(*other)">PurePath.relative_to(*<em>other</em>)</h5><p>对象所表示的路径相对于此路径的版本。如果不可能，则引发ValueError：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PurePosixPath(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.relative_to(<span class="string">'/'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'etc/passwd'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.relative_to(<span class="string">'/etc'</span>)</span><br><span class="line">PurePosixPath(<span class="string">'passwd'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.relative_to(<span class="string">'/usr'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"pathlib.py"</span>, line <span class="number">694</span>, <span class="keyword">in</span> relative_to</span><br><span class="line">    .format(str(self), str(formatted)))</span><br><span class="line">ValueError: <span class="string">'/etc/passwd'</span> does <span class="keyword">not</span> start <span class="keyword">with</span> <span class="string">'/usr'</span></span><br></pre></td></tr></table></figure><h5 id="PurePath-with_name(name)">PurePath.with_name(<em>name</em>)</h5><p>返回一个已更改名称的新路径。如果原始路径没有名称，则引发ValueError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PureWindowsPath(<span class="string">'c:/Downloads/pathlib.tar.gz'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.with_name(<span class="string">'setup.py'</span>)</span><br><span class="line">PureWindowsPath(<span class="string">'c:/Downloads/setup.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PureWindowsPath(<span class="string">'c:/'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.with_name(<span class="string">'setup.py'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/home/antoine/cpython/default/Lib/pathlib.py"</span>, line <span class="number">751</span>, <span class="keyword">in</span> with_name</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">"%r has an empty name"</span> % (self,))</span><br><span class="line">ValueError: PureWindowsPath(<span class="string">'c:/'</span>) has an empty name</span><br></pre></td></tr></table></figure><h5 id="PurePath-with_suffix(suffix)">PurePath.with_suffix(<em>suffix</em>)</h5><p>返回一个新路径，其中后缀已更改。如果原始路径没有后缀，则会追加新的后缀。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">p</span> = PureWindowsPath(<span class="string">'c:/Downloads/pathlib.tar.gz'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">p</span>.with_suffix(<span class="string">'.bz2'</span>)</span><br><span class="line"><span class="function"><span class="title">PureWindowsPath</span><span class="params">(<span class="string">'c:/Downloads/pathlib.tar.bz2'</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">p</span> = PureWindowsPath(<span class="string">'README'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">p</span>.with_suffix(<span class="string">'.txt'</span>)</span><br><span class="line"><span class="function"><span class="title">PureWindowsPath</span><span class="params">(<span class="string">'README.txt'</span>)</span></span></span><br></pre></td></tr></table></figure><h4 id="Concrete_paths">Concrete paths</h4><p>具体路径是纯路径类的子类。除了后者提供的操作之外，它们还提供对路径对象执行系统调用的方法。有三种方法可以实例化具体路径：</p><h5 id="class_pathlib-Path(*pathsegments)"><em>class</em> pathlib.Path(*<em>pathsegments</em>)</h5><p>这个类是PurePath的一个子类，表示系统路径味道的具体路径（实例化它可以创建PosixPath或WindowsPath）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path(<span class="string">'setup.py'</span>)</span><br><span class="line">PosixPath(<span class="string">'setup.py'</span>)</span><br></pre></td></tr></table></figure><p>路径指定类似于PurePath。</p><h5 id="class_pathlib-PosixPath(*pathsegments)"><em>class</em> pathlib.PosixPath(*<em>pathsegments</em>)</h5><p>Path和PurePosixPath的一个子类，这个类表示具体的非Windows文件系统路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PosixPath(<span class="string">'/etc'</span>)</span><br><span class="line">PosixPath(<span class="string">'/etc'</span>)</span><br></pre></td></tr></table></figure><p>路径指定类似于PurePath。</p><h5 id="class_pathlib-WindowsPath(*pathsegments)">class pathlib.WindowsPath(*<em>pathsegments</em>)</h5><p>这个类是Path和PureWindowsPath的子类，它表示具体的Windows文件系统路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>WindowsPath(<span class="string">'c:/Program Files/'</span>)</span><br><span class="line">WindowsPath(<span class="string">'c:/Program Files'</span>)</span><br></pre></td></tr></table></figure><p>路径指定类似于PurePath。</p><p>你只能实例化与你的系统对应的类风格（允许系统调用不兼容的路径，可能会导致应用程序中的错误或故障）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.name</span><br><span class="line"><span class="string">'posix'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path(<span class="string">'setup.py'</span>)</span><br><span class="line">PosixPath(<span class="string">'setup.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PosixPath(<span class="string">'setup.py'</span>)</span><br><span class="line">PosixPath(<span class="string">'setup.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>WindowsPath(<span class="string">'setup.py'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"pathlib.py"</span>, line <span class="number">798</span>, <span class="keyword">in</span> __new__</span><br><span class="line">    % (cls.__name__,))</span><br><span class="line">NotImplementedError: cannot instantiate <span class="string">'WindowsPath'</span> on your system</span><br></pre></td></tr></table></figure><h4 id="方法">方法</h4><p>除了纯路径方法外，具体路径还提供以下方法。如果系统调用失败（例如，路径不存在），这些方法中的许多都会引发OSError。</p><h5 id="classmethod*_Path-cwd()">classmethod* Path.cwd()</h5><p>返回一个表示当前目录的新路径对象（由os.getcwd()返回）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path.cwd()</span><br><span class="line">PosixPath(<span class="string">'/home/antoine/pathlib'</span>)</span><br></pre></td></tr></table></figure><h5 id="classmethod_Path-hom()">classmethod Path.hom()</h5><p>返回一个新的路径对象，该对象表示用户的主目录（由os.path.expanduser（）返回，带有~结构）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path.home()</span><br><span class="line">PosixPath(<span class="string">'/home/antoine'</span>)</span><br></pre></td></tr></table></figure><p>New in version 3.5.</p><h5 id="Path-stat()">Path.stat()</h5><p>返回关于此路径的信息（类似于os.stat（））。结果在每次调用这个方法时都会被查询出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Path(<span class="string">'setup.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.stat().st_size</span><br><span class="line"><span class="number">956</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.stat().st_mtime</span><br><span class="line"><span class="number">1327883547.852554</span></span><br></pre></td></tr></table></figure><h5 id="Path-chmod(mode)">Path.chmod(<em>mode</em>)</h5><p>更改文件模式和权限，如os.chmod()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Path(<span class="string">'setup.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.stat().st_mode</span><br><span class="line"><span class="number">33277</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.chmod(<span class="number">0o444</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.stat().st_mode</span><br><span class="line"><span class="number">33060</span></span><br></pre></td></tr></table></figure><h5 id="Path-exists()">Path.exists()</h5><p>该路径是否指向现有的文件或目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path(<span class="string">'.'</span>).exists()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path(<span class="string">'setup.py'</span>).exists()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path(<span class="string">'/etc'</span>).exists()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Path(<span class="string">'nonexistentfile'</span>).exists()</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果路径指向符号链接，则存在（）返回符号链接指向的是现有的文件还是目录。</p></blockquote><h5 id="Path-expanduser()">Path.expanduser()</h5><p>返回一个新路径，其中包含展开的~和~user构造，由os.path.expanduser()返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = PosixPath(<span class="string">'~/films/Monty Python'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.expanduser()</span><br><span class="line">PosixPath(<span class="string">'/home/eric/films/Monty Python'</span>)</span><br></pre></td></tr></table></figure><h5 id="Path-glob(pattern)">Path.glob(<em>pattern</em>)</h5><p>将此路径所表示的目录中的给定模式全局化，生成所有匹配的文件（任何类型的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(Path(<span class="string">'.'</span>).glob(<span class="string">'*.py'</span>))</span><br><span class="line">[PosixPath(<span class="string">'pathlib.py'</span>), PosixPath(<span class="string">'setup.py'</span>), PosixPath(<span class="string">'test_pathlib.py'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(Path(<span class="string">'.'</span>).glob(<span class="string">'*/*.py'</span>))</span><br><span class="line">[PosixPath(<span class="string">'docs/conf.py'</span>)]</span><br></pre></td></tr></table></figure><p>“**”模式意味着“此目录和所有子目录，递归地”。换句话说，它支持递归全局化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(Path(<span class="string">'.'</span>).glob(<span class="string">'**/*.py'</span>))</span><br><span class="line">[PosixPath(<span class="string">'build/lib/pathlib.py'</span>),</span><br><span class="line"> PosixPath(<span class="string">'docs/conf.py'</span>),</span><br><span class="line"> PosixPath(<span class="string">'pathlib.py'</span>),</span><br><span class="line"> PosixPath(<span class="string">'setup.py'</span>),</span><br><span class="line"> PosixPath(<span class="string">'test_pathlib.py'</span>)]</span><br></pre></td></tr></table></figure><blockquote><p>注意：在大型目录树中使用“**”模式可能消耗大量的时间。</p></blockquote><h5 id="Path-group()">Path.group()</h5><p>返回拥有该文件的组的名称。如果文件的gid在系统数据库中没有找到，则会引发KeyError。</p><h5 id="Path-is_dir()">Path.is_dir()</h5><p>返回True如果路径指向一个目录（或指向一个目录的符号链接），则False指向另一种文件。如果路径不存在或符号链接已损坏，也会返回False；其他错误（如权限错误）也会被传播。</p><h5 id="Path-is_file()">Path.is_file()</h5><p>返回真如果路径指向常规文件（或指向常规文件的符号链接），则Falseif指向另一种文件。如果路径不存在或符号链接已损坏，也会返回False；其他错误（如权限错误）也会被传播。</p><h5 id="Path-is_mount()">Path.is_mount()</h5><p>如果路径是一个挂载点，返回True：文件系统中已挂载不同文件系统的点。在POSIX上，函数检查路径的父路径/..，是否在与路径不同的设备上，或者路径/..，路径指向同一设备上的同一个i节点 —这应该可以检测所有Unix和POSIX变体的挂载点。没有在Windows上实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该模块提供表示文件系统路径的类，其语义适用于不同的操作系统。 pathlib类在纯路径之间划分，纯路径提供纯粹的计算操作而没有I / O，以及具体路径，它继承纯路径但也提供I / O操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/0
      
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
      <category term="path" scheme="yuluo-ding.github.io/tags/path/"/>
    
  </entry>
  
  <entry>
    <title>恢复Chrome的地址栏www</title>
    <link href="yuluo-ding.github.io/2018/09/10/%E6%81%A2%E5%A4%8DChrome%E7%9A%84%E5%9C%B0%E5%9D%80%E6%A0%8Fwww/"/>
    <id>yuluo-ding.github.io/2018/09/10/恢复Chrome的地址栏www/</id>
    <published>2018-09-10T02:30:58.000Z</published>
    <updated>2018-09-10T02:32:31.241Z</updated>
    
    <content type="html"><![CDATA[<ol><li>打开chrome</li><li>地址栏输入</li><li>chrome://flags/#omnibox-ui-hide-steady-state-url-scheme-and-subdomains</li><li>将选项改为disabled</li><li>重启浏览器</li></ol><p>恢复HTTPS 安全图标</p><ol><li>chrome://flags/#simplify-https-indicator</li><li>将选项改为</li><li>enabled（show secure chip for non-ev https pages）</li><li>重启浏览器</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;打开chrome&lt;/li&gt;
&lt;li&gt;地址栏输入&lt;/li&gt;
&lt;li&gt;chrome://flags/#omnibox-ui-hide-steady-state-url-scheme-and-subdomains&lt;/li&gt;
&lt;li&gt;将选项改为disabled&lt;/li&gt;
      
    
    </summary>
    
      <category term="Google" scheme="yuluo-ding.github.io/categories/Google/"/>
    
    
      <category term="Chrome" scheme="yuluo-ding.github.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>Python利用哈希值比较两个文件的一致性</title>
    <link href="yuluo-ding.github.io/2018/09/09/Python%E5%88%A9%E7%94%A8%E5%93%88%E5%B8%8C%E5%80%BC%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>yuluo-ding.github.io/2018/09/09/Python利用哈希值比较两个文件的一致性/</id>
    <published>2018-09-09T15:19:53.000Z</published>
    <updated>2018-09-09T15:26:35.645Z</updated>
    
    <content type="html"><![CDATA[<p>Python的内置函数hash(),深入发现通过python的哈希值可以做很多的事情</p><h3 id="实现原理">实现原理</h3><p><a href="https://www.wikiwand.com/zh-cn/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8" target="_blank" rel="noopener"><strong>散列函数</strong></a>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a href="https://www.wikiwand.com/zh-cn/%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在<a href="https://www.wikiwand.com/zh-cn/%E6%95%A3%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">散列表</a>和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p><p><strong>加密散列函数</strong>，是散列函数的一种。它被认为是一种单向函数，也就是说极其难以由散列函数输出的結果，回推输入的资料是什么。这样的单向函数被称为“现代密码学的驮马”。这种散列函数的输入资料，通常被称为讯息（message），而它的输出结果，经常被称为讯息摘要（message digest）或摘要（digest）。它的过程如下：</p><p><img src="https://i.loli.net/2018/09/09/5b953b1d11088.png" alt=""></p><h3 id="具体实现">具体实现</h3><h4 id="MD5">MD5</h4><p>MD5的全称是Message-Digest Algorithm 5（信息-摘要算法）。128位长度。目前MD5是一种不可逆算法。具有很高的安全性。它对应任何字符串都可以加密成一段唯一的固定长度的代码。</p><h4 id="SHA1">SHA1</h4><p>SHA1的全称是Secure Hash Algorithm(安全哈希算法) 。SHA1基于MD5，加密后的数据长度更长,它对长度小于264的输入，产生长度为160bit的散列值。比MD5多32位。<br> 因此，比MD5更加安全，但SHA1的运算速度就比MD5要慢了。</p><p>我们将演示<strong>使用MD5散列算法来hash文件</strong>。 我们不会一次性提取全部文件数据，因为一些文件非常大，会很消耗内存甚至一次性放不下。将文件分割成小块读取将使处理过程高效地使用内存。<br> 在Python中内置的 hashlib 模块就包括了 md5 和 sha1 算法。而且使用起来也极为方便，我们使用md5算法来实现我们比较文件一致性的功能，我们会使用update()方法来对这个对象填充任意的字符串。在任何时候你都可以使用digest()或hexdigest()方法问它要目前为止填充的字符串的摘要。我们需要了解以下几个函数：</p><blockquote><p><strong>hash.update(arg)</strong></p><p><strong>hash.digest()</strong></p><p><strong>hash.hexdigest()</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_md5</span><span class="params">(f)</span>:</span></span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment">#如果不用二进制打开文件，则需要先编码</span></span><br><span class="line">        <span class="comment">#data = f.read(1024).encode('utf-8')</span></span><br><span class="line">        data = f.read(<span class="number">1024</span>)  <span class="comment">#将文件分块读取</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        m.update(data)</span><br><span class="line">    <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment">#将file2文件写入改动了一个位数的数据</span></span><br><span class="line">txt1 = <span class="string">'你好么?我可以用下面这段代码验证一下：'</span></span><br><span class="line">txt2 = <span class="string">'你好么?我可以用下面这段代码验证一下：1'</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'1.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f1, open(<span class="string">'2.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    f1.write(txt1)</span><br><span class="line">    f2.write(txt2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'1.txt'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f1, open(<span class="string">'2.txt'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    file1_md5 = get_file_md5(f1)</span><br><span class="line">    file2_md5 = get_file_md5(f2)</span><br><span class="line">    print(<span class="string">'file1_md5:'</span>,file1_md5)</span><br><span class="line">    print(<span class="string">'file2_md5:'</span>,file2_md5)</span><br><span class="line">    <span class="keyword">if</span> file1_md5 != file2_md5:</span><br><span class="line">        print(<span class="string">'file has changed'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'file not changed'</span>)</span><br></pre></td></tr></table></figure><p>在代码中，我们通过将两段字符串txt1,txt2来模拟文件的改动，分别写入1.txt,2.txt,然后我们将两个文件分别读取，计算它们的MD5值，通过比较MD5值便可以知道它们是否一致。<br><strong>需要注意</strong>：<br> 1.是文件打开方式一定要是二进制方式，既打开文件时使用b模式，否则Hash计算是基于文本的那将得到错误的文件Hash，如果不用’rb’去读的话，而用’r’去读的话，我们读取的是uncode的编码，然后我们将读取到的内容编码成’utf-8’，即encode(‘utf-8’),然后进行MD5计算也是可以的。<br> 2.为了避免读入的文件过大，我们是分块读取的。</p><p>简书：楼上小宇：<a href="https://www.jianshu.com/u/1621b29625df" target="_blank" rel="noopener">http://www.jianshu.com/u/1621b29625df</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python的内置函数hash(),深入发现通过python的哈希值可以做很多的事情&lt;/p&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.wikiwand.com/zh-cn/%E6%95%A3%E5%88%97%E5%87
      
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
      <category term="Hash" scheme="yuluo-ding.github.io/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>Python 利用paramiko模块监控服务器</title>
    <link href="yuluo-ding.github.io/2018/08/17/python-%E5%88%A9%E7%94%A8paramiko%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>yuluo-ding.github.io/2018/08/17/python-利用paramiko模块监控服务器/</id>
    <published>2018-08-17T08:22:28.000Z</published>
    <updated>2018-08-17T08:37:15.835Z</updated>
    
    <content type="html"><![CDATA[<p>在需要对远程服务器进行监控或者一些文件操作的时候, 可以使用paramiko 模块来操作.</p><p>安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install paramiko</span><br></pre></td></tr></table></figure><p>Linux 下还得安装<strong>python-devel</strong>, 不然会报错</p><p>下面是示例代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sshCmd</span><span class="params">(ip, username, passwd, cmds)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client = paramiko.SSHClient()</span><br><span class="line">        client.load_system_host_keys()</span><br><span class="line">        client.set_missing_host_key_policy(paramiko.AutoAddPolicy)</span><br><span class="line">        client.connect(ip, <span class="number">22</span>, username, passwd, timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> cmd <span class="keyword">in</span> cmds:</span><br><span class="line">            stdin, stdout, stderr = client.exec_command(cmd)</span><br><span class="line">            lines = stdout.readlines()</span><br><span class="line">            <span class="comment"># print out</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                <span class="keyword">print</span> line,</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t 运行完毕\r\n'</span> % (ip)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t 运行失败,失败原因\r\n%s'</span> % (ip, e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        client.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#上传文件       </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uploadFile</span><span class="params">(ip,username,passwd)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        t=paramiko.Transport((ip,<span class="number">22</span>))</span><br><span class="line">        t.connect(username=username,password=passwd)</span><br><span class="line">        sftp=paramiko.SFTPClient.from_transport(t)</span><br><span class="line">        remotepath=<span class="string">'/root/main.py'</span></span><br><span class="line">        localpath=<span class="string">'/home/data/javawork/pythontest/src/main.py'</span></span><br><span class="line">        sftp.put(localpath,remotepath)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'上传文件成功'</span></span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t 运行失败,失败原因\r\n%s'</span> % (ip, e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        t.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载文件 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadFile</span><span class="params">(ip,username,passwd)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        t=paramiko.Transport((ip,<span class="number">22</span>))</span><br><span class="line">        t.connect(username=username,password=passwd)</span><br><span class="line">        sftp=paramiko.SFTPClient.from_transport(t)</span><br><span class="line">        remotepath=<span class="string">'/root/storm-0.9.0.1.zip'</span></span><br><span class="line">        localpath=<span class="string">'/home/data/javawork/pythontest/storm.zip'</span></span><br><span class="line">        sftp.get(remotepath,localpath)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'下载文件成功'</span></span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s\t 运行失败,失败原因\r\n%s'</span> % (ip, e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        t.close()  </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 需要执行的命令列表</span></span><br><span class="line">    cmds = [<span class="string">'ls /root'</span>, <span class="string">'ifconfig'</span>]</span><br><span class="line">    <span class="comment"># 需要进行远程监控的服务器列表</span></span><br><span class="line">    servers = [<span class="string">'xxx.xxx.xxx.xxx'</span>]</span><br><span class="line">     </span><br><span class="line">    username = <span class="string">"root"</span></span><br><span class="line">    passwd = <span class="string">"xxxxxx"</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"程序开始运行%s"</span> % datetime.datetime.now()</span><br><span class="line">    <span class="comment"># 每一台服务器创建一个线程处理</span></span><br><span class="line">    <span class="keyword">for</span> server <span class="keyword">in</span> servers:</span><br><span class="line">        th = threading.Thread(target=sshCmd, args=(server, username, passwd, cmds))</span><br><span class="line">        th.start()</span><br><span class="line">        threads.append(th)</span><br><span class="line">         </span><br><span class="line">    <span class="comment"># 等待线程运行完毕</span></span><br><span class="line">    <span class="keyword">for</span> th <span class="keyword">in</span> threads:</span><br><span class="line">        th.join()</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"程序结束运行%s"</span> % datetime.datetime.now()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#测试文件的上传与下载</span></span><br><span class="line">    uploadFile(servers[<span class="number">0</span>],username,passwd)</span><br><span class="line">    downloadFile(servers[<span class="number">0</span>],username,passwd)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在需要对远程服务器进行监控或者一些文件操作的时候, 可以使用paramiko 模块来操作.&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
      <category term="python, linux" scheme="yuluo-ding.github.io/tags/python-linux/"/>
    
  </entry>
  
  <entry>
    <title>iTunes 搜索 API</title>
    <link href="yuluo-ding.github.io/2018/08/15/iTunes-%E6%90%9C%E7%B4%A2-API/"/>
    <id>yuluo-ding.github.io/2018/08/15/iTunes-搜索-API/</id>
    <published>2018-08-15T15:25:42.000Z</published>
    <updated>2018-08-15T15:40:11.785Z</updated>
    
    <content type="html"><![CDATA[<p>这个搜索API允许你通过关键词在你的网站上搜索iTunes Store，App Store, iBooks Store and Mac App Store。你可以搜索各种内容；包括应用、图书、电影、广播、音乐、视频、有声读物以及TV节目。你也可以调用一个实名查询请求来创建内容库之间的映射和数字目录。开发者可以使用API里的推广的内容，包括歌曲预览，音乐录像，专辑封面和APP图标只用在推广的店面，不用于娱乐用途。从API里使用音乐样本及其他必须和店面徽章相似。<a href="https://link.jianshu.com?t=https://affiliate.itunes.apple.com/resources/documentation/itunes-store-web-service-search-api/#legal" target="_blank" rel="noopener">条款和条件适用</a>。</p><p>这项计划允许当你的网站或者app获得点击后获得一些佣金。该项计划更多信息请查看：<a href="https://link.jianshu.com/?t=http://www.apple.com/itunes/affiliates" target="_blank" rel="noopener">http://www.apple.com/itunes/affiliates</a>。</p><p>通过web去查找并且显示结果在web网站上。你必须创建一个搜索区域，通过完全限定的URL请求iTunes Store，并从返回的结果中解析JSON。然后将结果显示在web上。 完整的网址必须有以下格式：</p><p><code>https://itunes.apple.com/search?parameterkeyvalue</code></p><p>在参数里有一个或多个键值对，来详细说明你返回的结果。</p><p>构造一个参数键值对，你必须将每个参数的key等于（=）一个字符串value。例如：key1 =value1。创建一个字符串键值对，你必须将每对键值对用与（&amp;）符号链接。例如:key1=value1&amp;key2=value2&amp;key3=value3</p><p>注：当您为网站创建搜索域和脚本时，你应该使用动态脚本标签你的XMLHTTP脚本调用请求。例如:</p><blockquote><p>key1=value1</p></blockquote><p>您可以使用下表定义的参数的key和value来搜索iTunes Store，App Store，iBooks商店和Mac App Store里面的内容：</p><table><thead><tr><th>Parameter Key</th><th>Description</th><th>Required</th><th>Values</th></tr></thead><tbody><tr><td>term</td><td>The URL-encoded text string you want to search for. For example: jack+johnson.</td><td>Y</td><td>Any URL-encoded text string. Note: URL encoding replaces spaces with the plus (+) character and all characters except the following are encoded: letters, numbers, periods (.), dashes (-), underscores (_), and asterisks (*).</td></tr><tr><td>country</td><td>The two-letter country code for the store you want to search. The search uses the default store front for the specified country. For example: US. The default is US.</td><td>Y</td><td>See <a href="http://en.wikipedia.org/wiki/%20ISO_3166-1_alpha-2" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/ ISO_3166-1_alpha-2</a> for a list of ISO Country Codes.</td></tr><tr><td>media</td><td>The media type you want to search for. For example: movie. The default is all.</td><td>N</td><td>movie, podcast, music, musicVideo, audiobook, shortFilm, tvShow, software, ebook, all</td></tr><tr><td>entity</td><td>The type of results you want returned, relative to the specified media type. For example: movieArtist for a movie media type search. The default is the track entity associated with the specified media type.</td><td>N</td><td>The following entities are available for each media type:moviemovieArtist, moviepodcastpodcastAuthor, podcastmusicmusicArtist, musicTrack, album, musicVideo, mix, song Please note that “musicTrack” can include both songs and music videos in the resultsmusicVideomusicArtist, musicVideoaudiobookaudiobookAuthor, audiobookshortFilmshortFilmArtist, shortFilmtvShowtvEpisode, tvSeasonsoftwaresoftware, iPadSoftware, macSoftwareebookebookallmovie, album, allArtist, podcast, musicVideo, mix, audiobook, tvSeason, allTrack</td></tr><tr><td>attribute</td><td>The attribute you want to search for in the stores, relative to the specified media type. For example, if you want to search for an artist by name specify entity=allArtist&amp;attribute=allArtistTerm. In this example, if you search for term=maroon, iTunes returns “Maroon 5” in the search results, instead of all artists who have ever recorded a song with the word “maroon” in the title.The default is all attributes associated with the specified media type.</td><td>N</td><td>The following attributes are available for each media type:movieactorTerm, genreIndex, artistTerm, shortFilmTerm, producerTerm, ratingTerm, directorTerm, releaseYearTerm, featureFilmTerm, movieArtistTerm, movieTerm, ratingIndex, descriptionTermpodcasttitleTerm, languageTerm, authorTerm, genreIndex, artistTerm, ratingIndex, keywordsTerm, descriptionTermmusicmixTerm, genreIndex, artistTerm, composerTerm, albumTerm, ratingIndex, songTermmusicVideogenreIndex, artistTerm, albumTerm, ratingIndex, songTermaudiobooktitleTerm, authorTerm, genreIndex, ratingIndexshortFilmgenreIndex, artistTerm, shortFilmTerm, ratingIndex, descriptionTermsoftwaresoftwareDevelopertvShowgenreIndex, tvEpisodeTerm, showTerm, tvSeasonTerm, ratingIndex, descriptionTermallactorTerm, languageTerm, allArtistTerm, tvEpisodeTerm, shortFilmTerm, directorTerm, releaseYearTerm, titleTerm, featureFilmTerm, ratingIndex, keywordsTerm, descriptionTerm, authorTerm, genreIndex, mixTerm, allTrackTerm, artistTerm, composerTerm, tvSeasonTerm, producerTerm, ratingTerm, songTerm, movieArtistTerm, showTerm, movieTerm, albumTerm</td></tr><tr><td>callback</td><td>The name of the Javascript callback function you want to use when returning search results to your website. For example: wsSearchCB.</td><td>Y, for cross-site searches</td><td>wsSearchCB</td></tr><tr><td>limit</td><td>The number of search results you want the iTunes Store to return. For example: 25.The default is 50.</td><td>N</td><td>1 to 200</td></tr><tr><td>lang</td><td>The language, English or Japanese, you want to use when returning search results. Specify the language using the five-letter codename. For example: en_us.The default is en_us (English).</td><td>N</td><td>en_us, ja_jp</td></tr><tr><td>version</td><td>The search result key version you want to receive back from your search.The default is 2.</td><td>N</td><td>1, 2</td></tr><tr><td>explicit</td><td>A flag indicating whether or not you want to include explicit content in your search results.The default is Yes.</td><td>N</td><td>Yes, No</td></tr></tbody></table><ul><li>关键是要正确编码你的URL才能被委托会员链接。在编码原始链接附属票据可以在<a href="https://link.jianshu.com?t=https://affiliate.itunes.apple.com/resources/documentation/linking-to-the-itunes-music-store/" target="_blank" rel="noopener">Advanced Affiliate Linking</a>的文档中找到。</li><li>为了提高请求时间，通过指定适当的limit参数，在检索api的时候返回极少数的结果。</li><li>大型网站应该建立缓存逻辑，检索查找api的请求。为了说明这一点，请稍后查看本篇文章的Caching Architecture。</li></ul><p>以下是具体的搜索请求完全合格的URL的例子：</p><ul><li>要搜索所有杰克·约翰逊的音频和视频内容（电影，播客，音乐，音乐视频，有声读物，电影短片和电视节目），您的网址将如下所示：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/search?term=jack+johnson" target="_blank" rel="noopener">https://itunes.apple.com/search?term=jack+johnson</a> </li><li>要搜索所有杰克·约翰逊的音频和视频内容（电影，播客，音乐，音乐视频，有声读物，电影短片和电视节目），并且只返回前25条。您的网址将如下所示：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/search?term=jack+johnson&amp;limit=25" target="_blank" rel="noopener">https://itunes.apple.com/search?term=jack+johnson&amp;limit=25</a> </li><li>要检索杰克·约翰逊的音频，您的网址将如下所示：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/search?term=jack+johnson&amp;entity=musicVideo" target="_blank" rel="noopener">https://itunes.apple.com/search?term=jack+johnson&amp;entity=musicVideo</a> </li><li>要搜索所有吉姆·琼斯音频和视频内容，并返回只从加拿大iTunes商店的结果，您的网址将如下所示：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/search?term=jim+jones&amp;country=ca" target="_blank" rel="noopener">https://itunes.apple.com/search?term=jim+jones&amp;country=ca</a> </li><li>要搜索名为“Yelp的”应用程序和来自美国的iTunes商店只返回的结果，您的网址将如下所示：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/search?term=yelp&amp;country=us&amp;entity=software" target="_blank" rel="noopener">https://itunes.apple.com/search?term=yelp&amp;country=us&amp;entity=software</a></li></ul><p>你也可以创建一个基于iTunes IDs, UPCs/ EANs的搜索请求去商店里面搜索内容。和所有音乐指南（AMG）标识的存储内容。基于ID的查找速度更快，而且含有较少的假阳性结果。</p><p>以下是具体的查找请求完全合格的URL的例子：</p><ul><li><p>通过iTunes艺术家ID查找杰克·约翰逊：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?id=909253" target="_blank" rel="noopener">https://itunes.apple.com/lookup?id=909253</a> </p></li><li><p>通过iTunes ID查找Yelp的软件应用程序：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?id=284910350" target="_blank" rel="noopener">https://itunes.apple.com/lookup?id=284910350</a> </p></li><li><p>通过AMG艺术家ID查找杰克·约翰逊：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?amgArtistId=468749" target="_blank" rel="noopener">https://itunes.apple.com/lookup?amgArtistId=468749</a> </p></li><li><p>通过AMG艺术家的ID查找多个艺术家：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?amgArtistId=468749,5723" target="_blank" rel="noopener">https://itunes.apple.com/lookup?amgArtistId=468749,5723</a> </p></li><li><p>查找的杰克·约翰逊的所有专辑：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?id=909253&amp;entity=album" target="_blank" rel="noopener">https://itunes.apple.com/lookup?id=909253&amp;entity=album</a> </p></li><li><p>其AMG艺术家的ID查找多个艺术家和获得每个艺术家的前5张专辑：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?amgArtistId=468749,5723&amp;entity=album&amp;limit=5" target="_blank" rel="noopener">https://itunes.apple.com/lookup?amgArtistId=468749,5723&amp;entity=album&amp;limit=5</a> </p></li><li><p>通过AMG艺术家的ID查找多个艺术家和获得每个艺术家的5最新歌曲：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?amgArtistId=468749,5723&amp;entity=song&amp;limit=5&amp;sort=recent" target="_blank" rel="noopener">https://itunes.apple.com/lookup?amgArtistId=468749,5723&amp;entity=song&amp;limit=5&amp;sort=recent</a> </p></li><li><p>通过UPC查找一个专辑或视频：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?upc=720642462928" target="_blank" rel="noopener">https://itunes.apple.com/lookup?upc=720642462928</a> </p></li><li><p>通过UPC查找专辑，包括这张专辑的曲目：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?upc=720642462928&amp;entity=song" target="_blank" rel="noopener">https://itunes.apple.com/lookup?upc=720642462928&amp;entity=song</a> </p></li><li><p>通过专辑ID来查找一个专辑：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?amgAlbumId=15175,15176,15177,15178,15183,15184,15187,1519,15191,15195,15197,15198" target="_blank" rel="noopener">https://itunes.apple.com/lookup?amgAlbumId=15175,15176,15177,15178,15183,15184,15187,1519,15191,15195,15197,15198</a> </p></li><li><p>通过AMG视频ID查找一部电影：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?amgVideoId=17120" target="_blank" rel="noopener">https://itunes.apple.com/lookup?amgVideoId=17120</a> </p></li><li><p>通过13位ISBN查找一本书：<br> <a href="https://link.jianshu.com?t=https://itunes.apple.com/lookup?isbn=9780316069359" target="_blank" rel="noopener">https://itunes.apple.com/lookup?isbn=9780316069359</a> </p><p>了解搜索结果你搜索的结果用JSON格式返回，JSON有两种结构：</p></li><li><p>一种key/value的集合。也可以称之为一种对象，这个概念类似于Java Map对象，一个Javascript字典，或Pearl/ Ruby的哈希值。对象是一个无序的名称/值对，用左括号开始（{）和一个右括号结束（}）。每个名称由双引号包围，后跟一个冒号（:)）;名称/值对用逗号（，）隔开。</p></li><li><p>值的有序列表，也称为阵列。数组是值的有序集合，用左括号开头（[），并以右括号结束（]）。值用逗号（，）分隔。 </p></li></ul><p>所有的JSON结果被编码为UTF-8。有关JSON的更多信息，请参阅<a href="https://link.jianshu.com/?t=http://www.json.org" target="_blank" rel="noopener">http://www.json.org</a>。</p><p>下面的示例显示在iTunes Store的歌曲JSON的结果 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"wrapperType"</span>:<span class="string">"track"</span>,</span><br><span class="line"> <span class="attr">"kind"</span>:<span class="string">"song"</span>,</span><br><span class="line"> <span class="attr">"artistId"</span>:<span class="number">909253</span>,</span><br><span class="line"> <span class="attr">"collectionId"</span>:<span class="number">120954021</span>,</span><br><span class="line"> <span class="attr">"trackId"</span>:<span class="number">120954025</span>,</span><br><span class="line"> <span class="attr">"artistName"</span>:<span class="string">"Jack Johnson"</span>,</span><br><span class="line"> <span class="attr">"collectionName"</span>:<span class="string">"Sing-a-Longs and Lullabies for the Film Curious George"</span>,</span><br><span class="line"> <span class="attr">"trackName"</span>:<span class="string">"Upside Down"</span>,</span><br><span class="line"> <span class="attr">"collectionCensoredName"</span>:<span class="string">"Sing-a-Longs and Lullabies for the Film Curious George"</span>,</span><br><span class="line"> <span class="attr">"trackCensoredName"</span>:<span class="string">"Upside Down"</span>,</span><br><span class="line"> <span class="attr">"artistViewUrl"</span>:<span class="string">"https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewArtist?id=909253"</span>,</span><br><span class="line"> <span class="attr">"collectionViewUrl"</span>:<span class="string">"https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewAlbum?i=120954025&amp;id=120954021&amp;s=143441"</span>,</span><br><span class="line"> <span class="attr">"trackViewUrl"</span>:<span class="string">"https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewAlbum?i=120954025&amp;id=120954021&amp;s=143441"</span>,</span><br><span class="line"> <span class="attr">"previewUrl"</span>:<span class="string">"http://a1099.itunes.apple.com/r10/Music/f9/54/43/mzi.gqvqlvcq.aac.p.m4p"</span>,</span><br><span class="line"> <span class="attr">"artworkUrl60"</span>:<span class="string">"http://a1.itunes.apple.com/r10/Music/3b/6a/33/mzi.qzdqwsel.60x60-50.jpg"</span>,</span><br><span class="line"> <span class="attr">"artworkUrl100"</span>:<span class="string">"http://a1.itunes.apple.com/r10/Music/3b/6a/33/mzi.qzdqwsel.100x100-75.jpg"</span>,</span><br><span class="line"> <span class="attr">"collectionPrice"</span>:<span class="number">10.99</span>,</span><br><span class="line"> <span class="attr">"trackPrice"</span>:<span class="number">0.99</span>,</span><br><span class="line"> <span class="attr">"collectionExplicitness"</span>:<span class="string">"notExplicit"</span>,</span><br><span class="line"> <span class="attr">"trackExplicitness"</span>:<span class="string">"notExplicit"</span>,</span><br><span class="line"> <span class="attr">"discCount"</span>:<span class="number">1</span>,</span><br><span class="line"> <span class="attr">"discNumber"</span>:<span class="number">1</span>,</span><br><span class="line"> <span class="attr">"trackCount"</span>:<span class="number">14</span>,</span><br><span class="line"> <span class="attr">"trackNumber"</span>:<span class="number">1</span>,</span><br><span class="line"> <span class="attr">"trackTimeMillis"</span>:<span class="number">210743</span>,</span><br><span class="line"> <span class="attr">"country"</span>:<span class="string">"USA"</span>,</span><br><span class="line"> <span class="attr">"currency"</span>:<span class="string">"USD"</span>,</span><br><span class="line"> <span class="attr">"primaryGenreName"</span>:<span class="string">"Rock"</span>&#125;</span><br></pre></td></tr></table></figure><p> 下表定义了JSON格式返回结果的键和值：</p><table><thead><tr><th>Result Key</th><th>Description</th><th>Returned</th><th>Return Values and Examples</th></tr></thead><tbody><tr><td>wrapperType</td><td>The name of the object returned by the search request.</td><td>Y</td><td>track, collection, artistFor example: track.</td></tr><tr><td>*explicitness</td><td>The Recording Industry Association of America (RIAA) parental advisory for the content returned by the search request.For more information, see <a href="http://itunes.apple.com/WebObjects/MZStore.woa/wa/parentalAdvisory" target="_blank" rel="noopener">http://itunes.apple.com/WebObjects/MZStore.woa/wa/parentalAdvisory</a>.</td><td>Y</td><td>explicit (explicit lyrics, possibly explicit album cover), cleaned (explicit lyrics “bleeped out”), notExplicit (no explicit lyrics)For example: “trackExplicitness”:”notExplicit”.</td></tr><tr><td>kind</td><td>The kind of content returned by the search request.</td><td>Y</td><td>book, album, coached-audio, feature-movie, interactive- booklet, music-video, pdf podcast, podcast-episode, software-package, song, tv- episode, artistFor example: song.</td></tr><tr><td>trackName</td><td>The name of the track, song, video, TV episode, and so on returned by the search request.</td><td>Y</td><td>For example: “Banana Pancakes”.</td></tr><tr><td>artistName</td><td>The name of the artist returned by the search request.</td><td>Y</td><td>For example: Jack Johnson.</td></tr><tr><td>collectionName</td><td>The name of the album, TV season, audiobook, and so on returned by the search request.</td><td>Y</td><td>For example: “In Between Dreams”.</td></tr><tr><td>*censoredName</td><td>The name of the album, TV season, audiobook, and so on returned by the search request, with objectionable words *’d out.<strong>Note:</strong> Artist names are never censored.</td><td>Y</td><td>For example: “S**t Happens”.</td></tr><tr><td>artworkUrl100, artworkUrl60</td><td>A URL for the artwork associated with the returned media type, sized to 100×100 pixels or 60×60 pixels.</td><td>Only returned when artwork is available</td><td>For example: “http:// a1.itunes.apple.com/jp/r10/Music/ y2005/m06/d03/h05/ s05.oazjtxkw.100×100-75.jpg”.</td></tr><tr><td>*viewURL</td><td>A URL for the content associated with the returned media type. You can click the URL to view the content in the iTunes Store.</td><td>Y</td><td>For example: “http:// itunes.apple.com/WebObjects/ MZStore.woa/wa/viewAlbum? i=68615807&amp;id=68615813&amp;s=1434 62”.</td></tr><tr><td>previewUrl</td><td>A URL referencing the 30-second preview file for the content associated with the returned media type. .</td><td>Only returned when media type is track</td><td>For example: “http:// a392.itunes.apple.com/jp/r10/ Music/y2005/m06/d03/h05/s05.zdzqlufu.p.m4p”.</td></tr><tr><td>trackTimeMillis</td><td>The returned track’s time in milliseconds.</td><td>Only returned when media type is track</td></tr></tbody></table><p> 缓存框架</p><p><img src="https://i.loli.net/2018/08/15/5b74494401e32.jpg" alt="cache-architecture-1.jpg"></p><p><strong>法律声明</strong> </p><p>开发人员可以使用某些促销内容，可以通过苹果公司提供，包括歌曲预览和音乐视频，专辑封面，和App图标（“促销内容”），促进了促销内容的主题的目的;提供了这种促销内容：</p><p>（一）被放置仅在促进该促销内容是基于内容页面; </p><p>（二）是接近了“iTunes下载”，“下载的应用程序商店”或“下载的iBooks商店”标志（如批准苹果公司）充当直接链接到iTunes中或App Store页面，消费者可以购买该宣传内容; </p><p>（三）包括归属指示促销内容是“提供了iTunes的礼遇”如果这样的促销内容包括歌曲或音乐视频预览; </p><p>（四）仅流，而不是下载，保存，缓存，或者与视频同步，如果这样的促销内容包括歌曲或音乐视频预览; </p><p>（五）不用于除了其促销目的独立娱乐价值</p><p>（六）不用于促进任何其他商品或服务。开发商承认，苹果提供的促销内容的“原样”，并拒绝任何和所有陈述或担保，包括但不限于非侵权。开发者应将与促销内容到苹果在收到立即连接收到任何索赔，并将根据要求苹果公司立刻删除任何促销内容。</p><p>本协议和您的宣传内容使用受加利福尼亚州法律管辖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个搜索API允许你通过关键词在你的网站上搜索iTunes Store，App Store, iBooks Store and Mac App Store。你可以搜索各种内容；包括应用、图书、电影、广播、音乐、视频、有声读物以及TV节目。你也可以调用一个实名查询请求来创建内
      
    
    </summary>
    
      <category term="Apple" scheme="yuluo-ding.github.io/categories/Apple/"/>
    
    
      <category term="iTunes" scheme="yuluo-ding.github.io/tags/iTunes/"/>
    
  </entry>
  
  <entry>
    <title>开启snippet的本地搜索功能</title>
    <link href="yuluo-ding.github.io/2018/08/10/%E5%BC%80%E5%90%AFsnippet%E7%9A%84%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
    <id>yuluo-ding.github.io/2018/08/10/开启snippet的本地搜索功能/</id>
    <published>2018-08-10T01:24:28.000Z</published>
    <updated>2018-08-10T01:42:09.642Z</updated>
    
    <content type="html"><![CDATA[<p>由于使用的是snippet的主题，使用文档已经说出了如何开启本地的搜索功能。</p><p>如果要使用本地站点搜索，必须安装插件hexo-generator-json-content来创建本地搜索json文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-generator-json-content@2.2.0 -S</span><br></pre></td></tr></table></figure><p>然后修改主题配置_config.yml文件下<code>jsonContent</code>相关参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 搜索</span></span><br><span class="line">jsonContent:</span><br><span class="line">  searchLocal: true // 是否启用本地搜索</span><br><span class="line">  searchGoogle: true //是否启用谷歌搜索</span><br><span class="line">  posts:</span><br><span class="line">    title: true</span><br><span class="line">    text: true</span><br><span class="line">    content: true</span><br><span class="line">    categories: true</span><br><span class="line">    tags: true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于使用的是snippet的主题，使用文档已经说出了如何开启本地的搜索功能。&lt;/p&gt;
&lt;p&gt;如果要使用本地站点搜索，必须安装插件hexo-generator-json-content来创建本地搜索json文件&lt;/p&gt;
&lt;figure class=&quot;highlight she
      
    
    </summary>
    
      <category term="hexo教程" scheme="yuluo-ding.github.io/categories/hexo%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="yuluo-ding.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>让终端走代理</title>
    <link href="yuluo-ding.github.io/2018/08/08/%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86/"/>
    <id>yuluo-ding.github.io/2018/08/08/让终端走代理/</id>
    <published>2018-08-08T15:21:42.000Z</published>
    <updated>2018-08-09T09:15:10.660Z</updated>
    
    <content type="html"><![CDATA[<p>在某些时候, mac  OS 下的终端在现在这个环境下. GitHub 等网站动不动连不上, 需要走代理. 现在可以有三种方式:</p><ul><li>Surge Mac 2 的增强模式</li><li>Proxifier 把终端设置为走代理模式</li><li>zsh 的配置模式</li></ul><p>其中可以在<code>.zshrc</code>的配置文件中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">where</span> proxy</span></span><br><span class="line">proxy () &#123;</span><br><span class="line">  export http_proxy="http://127.0.0.1:8888"</span><br><span class="line">  export https_proxy="http://127.0.0.1:8888"</span><br><span class="line">  echo "HTTP Proxy on"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">where</span> noproxy</span></span><br><span class="line">noproxy () &#123;</span><br><span class="line">  unset http_proxy</span><br><span class="line">  unset https_proxy</span><br><span class="line">  echo "HTTP Proxy off"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候输入 Proxy 打开代理模式，关闭代理时输入 noproxy 即可.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在某些时候, mac  OS 下的终端在现在这个环境下. GitHub 等网站动不动连不上, 需要走代理. 现在可以有三种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Surge Mac 2 的增强模式&lt;/li&gt;
&lt;li&gt;Proxifier 把终端设置为走代理模式&lt;/li&gt;
&lt;li&gt;z
      
    
    </summary>
    
      <category term="mac OS" scheme="yuluo-ding.github.io/categories/mac-OS/"/>
    
    
      <category term="terminal" scheme="yuluo-ding.github.io/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>npm升级所有可更新包</title>
    <link href="yuluo-ding.github.io/2018/08/07/npm%E5%8D%87%E7%BA%A7%E6%89%80%E6%9C%89%E5%8F%AF%E6%9B%B4%E6%96%B0%E5%8C%85/"/>
    <id>yuluo-ding.github.io/2018/08/07/npm升级所有可更新包/</id>
    <published>2018-08-07T15:38:51.000Z</published>
    <updated>2018-08-09T09:19:06.846Z</updated>
    
    <content type="html"><![CDATA[<p>使用npm管理node的包，可以使用<code>npm update &lt;name&gt;</code>对单个包升级，对于npm的版本大于 <code>2.6.1</code>,可以使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g</span><br></pre></td></tr></table></figure><p> 这样升级全部的包</p><p>如果上述不太方便, 还可以使用<code>shell脚本</code>和<code>npm-ckeck</code></p><h3 id="shell_脚本">shell 脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">set -e</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> -x</span></span><br><span class="line">for package in $(npm -g outdated --parseable --depth=0 | cut -d: -f2)</span><br><span class="line">do</span><br><span class="line">    npm -g install "$package"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="npm-check">npm-check</h3><p><a href="https://www.npmjs.com/package/npm-check" target="_blank" rel="noopener">npm-check</a>是用来检查npm依赖包是否有更新，错误以及不在使用的，我们也可以使用npm-check进行包的更新。</p><p>安装npm-check：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check</span><br></pre></td></tr></table></figure><p>检查npm包的状态:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm-check -u -g</span><br></pre></td></tr></table></figure><p>通过上下键可以移动光标，使用空格键可以选择需要处理的包，回车直接进行处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用npm管理node的包，可以使用&lt;code&gt;npm update &amp;lt;name&amp;gt;&lt;/code&gt;对单个包升级，对于npm的版本大于 &lt;code&gt;2.6.1&lt;/code&gt;,可以使用命令:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="前端" scheme="yuluo-ding.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="npm" scheme="yuluo-ding.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>macOS 升级JDK至1.8</title>
    <link href="yuluo-ding.github.io/2018/08/02/macOS-%E5%8D%87%E7%BA%A7JDK%E8%87%B31-8/"/>
    <id>yuluo-ding.github.io/2018/08/02/macOS-升级JDK至1-8/</id>
    <published>2018-08-02T15:55:13.000Z</published>
    <updated>2018-08-02T16:04:53.661Z</updated>
    
    <content type="html"><![CDATA[<p>Macbook Pro原生自带的Java JDK版本是1.6，而有的时候呢需要高一点的版本，这时候就需要升级JDK的版本。</p><p>通过<code>java -version</code>可以查看当前的版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java version "1.6.0_65"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.6.0_65-b14-468-11M4833)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-468, mixed mode)</span><br></pre></td></tr></table></figure><ol><li><p>首先去下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Java SE Developent Kit</a>，下载完成后安装上，安装好的jdk在这个位置:<code>/Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents</code></p></li><li><p>然后去苹果的官网下载最新的java版本 <a href="https://support.apple.com/en-us/HT204036" target="_blank" rel="noopener">Java From Apple</a>,下载完成安装上以后可以在 系统偏好设置–&gt;Java–&gt;Java控制面板 中查看Java相关的信息。</p></li><li><p>去JavaFramework索引目录下修改当前的jdk引用路径:<code>cd /System/Library/Frameworks/JavaVM.framework/Versions</code></p></li><li><p>移除旧的引用:<code>sudo rm CurrentJDK</code>，如果你的系统是最新的<code>10.13</code>的话，会有这个提示：<code>rm: CurrentJDK: Operation not permitted</code>。</p><blockquote><p>这是因为<code>EI Capitan</code>加入了<code>Rootless机制</code>，不再能够随心所欲的读写很多路径下得内容了，即使是设置了<code>root</code>权限也不行。 苹果这样做也是为了用户的安全考虑，避免用户误删文件，当然也能够在一定程度下减小恶意软件对用户造成危害的几率。 但是这是我们自己需要这样的操作怎么办呢 ？苹果也考虑到了大家的需求，可以这么做：</p><p><strong>1).</strong> 重启电脑，在将要启动的时候按住 <code>Command + R</code>键，进入恢复模式； </p><p><strong>2).</strong> 选择菜单栏中得使用工具，在其中打开终端；</p><p><strong>3).</strong> 输入 <code>csrutil disable</code>，暂时关闭<code>Rootless</code>； </p><p><strong>4).</strong> 重启即可继续操作。</p><p><strong>5).</strong> 如果想要恢复，可以再次重启并进入终端，输入 <code>csrutil enable</code> 即可。</p></blockquote></li><li><p>删除 <code>CurrentJDK</code> 后，不要离开当前目录，添加新的jdk引用路径：<code>sudo ln -s /Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents CurrentJDK</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Macbook Pro原生自带的Java JDK版本是1.6，而有的时候呢需要高一点的版本，这时候就需要升级JDK的版本。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;java -version&lt;/code&gt;可以查看当前的版本:&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="mac OS" scheme="yuluo-ding.github.io/categories/mac-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>国内外主流android第三方服务</title>
    <link href="yuluo-ding.github.io/2018/08/01/%E5%9B%BD%E5%86%85%E5%A4%96%E4%B8%BB%E6%B5%81android%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1/"/>
    <id>yuluo-ding.github.io/2018/08/01/国内外主流android第三方服务/</id>
    <published>2018-08-01T15:53:53.000Z</published>
    <updated>2018-08-01T15:55:36.368Z</updated>
    
    <content type="html"><![CDATA[<p><strong>统计分析</strong></p><p>国内：Talking Data, 可惜友盟现在启动就带上阿里全家桶。</p><p>国外: Flurry, 国外统计分析系统的标杆，免费的。</p><p><strong>Crash分析</strong></p><p>国内: 腾讯Bugly, 号称全球唯一自带ANR收集，其实原理很简单，不知别家为何不做。</p><p>国外: Crashlytics, 已经收归Twitter Fabric开发者工具集，免费好用。</p><p><strong>推送</strong></p><p>国内: LeanCloud，这个没实际用过，身边朋友反馈很好。</p><p>国外: Parse, 正如覃超所说,FB也在用，30qps免费限制，一般中小应用够用。</p><p><strong>分享</strong></p><p>国内: ShareSDK，专业做社交分享。</p><p>国外: 各社交平台自家SDK, 注意不同国家主流社交平台不同。</p><p><strong>评论</strong></p><p>国内：畅言, 基本抄的Disqus, 免费，算是良心产品了。</p><p>国外：Disqus, 基本不用考虑其他家的，虽然确实有竞品。</p><p><strong>广告变现</strong></p><p>国内：百度 or 广点通，两个效果差不多。</p><p>国外：FB or Google，做native广告，效果最佳。</p><p><strong>支付</strong></p><p>国内: 支付宝, 微信</p><p>国外: payssion, 专业做海外跨境收款的，能省很多事。</p><p><strong>短信验证</strong></p><p>国内：没用过，Google找一家最便宜的就行。</p><p>国外：Fabric Digits, twitter出品，居然不要钱。</p><p><strong>灰度测试</strong></p><p>国内：AppAdhoc，移动AB测试国内最专业的一家。</p><p>国外：optimizely, 支持Android, iOS, 直接在线改UI做AB测试, 三观都要颠覆了。</p><p><strong>云测</strong></p><p>国内：百度云测试。</p><p>国外：test in, 其实百度的也跑，国内的Android设备都卖到国外去了。</p><p><strong>客服</strong></p><p>国内：微客服, 有免费额度，中小应用够用。</p><p>国外：helpshift，国外最专业的客服平台。</p><p><strong>推广</strong></p><p>国内：这个真不了解。</p><p>国外：Appsflyer, 海外推广为数不多的选择之一。</p><p><strong>可视化分析</strong></p><p>国内：growingio, 还在内测中，linkedin数据分析大牛回国创业，据说黑科技，可以直接在app上实时查看各种转化率数据。</p><p>国外：appsee, 绝对黑科技，PM最爱。</p><p><strong>网络优化</strong></p><p>国外：TwinPrime, 颇具特色的网络优化服务。</p><p>国内：暂时还没发现同类产品，不过TwinPrime理论上是支持全球的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;统计分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;国内：Talking Data, 可惜友盟现在启动就带上阿里全家桶。&lt;/p&gt;
&lt;p&gt;国外: Flurry, 国外统计分析系统的标杆，免费的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Crash分析&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Apple" scheme="yuluo-ding.github.io/categories/Apple/"/>
    
    
  </entry>
  
  <entry>
    <title>相似图片检测：感知哈希算法之dHash的Python实现</title>
    <link href="yuluo-ding.github.io/2018/07/20/%E7%9B%B8%E4%BC%BC%E5%9B%BE%E7%89%87%E6%A3%80%E6%B5%8B%EF%BC%9A%E6%84%9F%E7%9F%A5%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B9%8BdHash%E7%9A%84Python%E5%AE%9E%E7%8E%B0/"/>
    <id>yuluo-ding.github.io/2018/07/20/相似图片检测：感知哈希算法之dHash的Python实现/</id>
    <published>2018-07-20T15:53:38.000Z</published>
    <updated>2018-07-20T16:26:48.528Z</updated>
    
    <content type="html"><![CDATA[<p>根据这篇文章<a href="https://blog.csdn.net/haluoluo211/article/details/52769325https://blog.csdn.net/haluoluo211/article/details/52769325" target="_blank" rel="noopener">相似图片检测：感知哈希算法之dHash的Python实现</a></p><p>实现步骤如下：</p><p>1、将图片缩放至9*8像素，即一共有8行，每行有9个像素</p><p>2、将缩放的图转为灰度图，每个像素由一个0到255的整数表示灰度</p><p>3、将每一行灰度值与第二个灰度值进行比较，如果大于则用1表示，否则用0表示，不同行间的灰度值不进行比较，比较后的结果可以得到由1、0组成的64个数值，该64个数值可以看作是该图片的指纹</p><p>4、将两张图的指纹进行比较，即将两个指纹相同位置的数值进行对比，如果相同则不计数，如不同则计数1，最终比较结果，如果计数小于5，即视为相同或相似的图片，如果大于10则视为两张不同的照片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /user/bin/python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  <span class="comment"># 导入pillow库下的image模块，主要用于图片缩放、图片灰度化、获取像素灰度值</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">'/Users/test/Downloads/photo'</span></span><br><span class="line">error_path = <span class="string">'/Users/test/Downloads/HEIC/error'</span></span><br><span class="line">res_path = <span class="string">'/Users/test/Downloads/HEIC/result.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># image为图片的路径，resize_width为缩放图片的宽度，resize_heith为缩放图片的高度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grayscale_Image</span><span class="params">(image, resize_width=<span class="number">9</span>, resize_heith=<span class="number">8</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        im = Image.open(image)  <span class="comment"># 使用Image的open方法打开图片</span></span><br><span class="line">        smaller_image = im.resize((resize_width, resize_heith))  <span class="comment"># 将图片进行缩放</span></span><br><span class="line">        grayscale_image = smaller_image.convert(<span class="string">'L'</span>)  <span class="comment"># 将图片灰度化</span></span><br><span class="line">        <span class="keyword">return</span> grayscale_image</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(image)</span><br><span class="line">        shutil.move(image, error_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_String</span><span class="params">(image, resize_width=<span class="number">9</span>, resize_heith=<span class="number">8</span>)</span>:</span></span><br><span class="line">    hash_string = <span class="string">""</span>  <span class="comment"># 定义空字符串的变量，用于后续构造比较后的字符串</span></span><br><span class="line">    pixels = list(grayscale_Image(image, resize_width, resize_heith).getdata())</span><br><span class="line">    <span class="comment"># 上一个函数grayscale_Image()缩放图片并返回灰度化图片，.getdata()方法可以获得每个像素的灰度值，使用内置函数list()将获得的灰度值序列化</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">1</span>, len(pixels) + <span class="number">1</span>):  <span class="comment"># 获取pixels元素个数，从1开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> row % resize_width:  <span class="comment"># 因不同行之间的灰度值不进行比较，当与宽度的余数为0时，即表示当前位置为行首位，我们不进行比较</span></span><br><span class="line">            <span class="keyword">if</span> pixels[row - <span class="number">1</span>] &gt; pixels[row]:  <span class="comment"># 当前位置非行首位时，我们拿前一位数值与当前位进行比较</span></span><br><span class="line">                hash_string += <span class="string">'1'</span>  <span class="comment"># 当为真时，构造字符串为1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash_string += <span class="string">'0'</span>  <span class="comment"># 否则，构造字符串为0</span></span><br><span class="line">        <span class="comment"># 最后可得出由0、1组64位数字字符串，可视为图像的指纹</span></span><br><span class="line">    <span class="keyword">return</span> int(hash_string, <span class="number">2</span>)  <span class="comment"># 把64位数当作2进制的数值并转换成十进制数值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Difference</span><span class="params">(dhash1, dhash2)</span>:</span></span><br><span class="line">    difference = dhash1 ^ dhash2  <span class="comment"># 将两个数值进行异或运算</span></span><br><span class="line">    <span class="keyword">return</span> bin(difference).count(<span class="string">'1'</span>)  <span class="comment"># 异或运算后计算两数不同的个数，即个数&lt;5，可视为同一或相似图片</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path_list = []</span><br><span class="line">    path_dic = &#123;&#125;</span><br><span class="line">    pic_list = []</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">'.jpg'</span>) <span class="keyword">or</span> file.endswith(<span class="string">'.JPG'</span>) <span class="keyword">or</span> file.endswith(<span class="string">'.PNG'</span>) <span class="keyword">or</span> file.endswith(<span class="string">'.png'</span>):</span><br><span class="line">            pic_list.append(file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> pic_list:</span><br><span class="line">        file_path = os.path.join(path, file)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            Image.open(file_path)</span><br><span class="line"></span><br><span class="line">            path_list.append(file_path)</span><br><span class="line"></span><br><span class="line">            tmp_hash = hash_String(file_path)</span><br><span class="line">            path_dic[file_path] = tmp_hash</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            shutil.move(file_path, error_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for key, value in path_dic.items():</span></span><br><span class="line">    <span class="comment">#     print(key, value)</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> path_dic.values():</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> path_dic.values():</span><br><span class="line">            tmp = Difference(i, j)</span><br><span class="line">            <span class="keyword">if</span> tmp &lt;= <span class="number">5</span>:</span><br><span class="line">                <span class="comment"># print(i, j)</span></span><br><span class="line">                <span class="comment"># list(dicxx.keys())[list(dicxx.values()).index("001")]</span></span><br><span class="line">                var_i = list(path_dic.keys())[list(path_dic.values()).index(i)]</span><br><span class="line">                var_j = list(path_dic.keys())[list(path_dic.values()).index(j)]</span><br><span class="line">                <span class="keyword">if</span> var_i != var_j:</span><br><span class="line">                    print(var_i, var_j)</span><br><span class="line">                    <span class="keyword">with</span> open(res_path, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                        f.write(var_i)</span><br><span class="line">                        f.write(var_j)</span><br><span class="line">                        f.write(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据这篇文章&lt;a href=&quot;https://blog.csdn.net/haluoluo211/article/details/52769325https://blog.csdn.net/haluoluo211/article/details/52769325&quot; targ
      
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 解决Vi输入中文乱码的问题</title>
    <link href="yuluo-ding.github.io/2018/06/19/Linux-%E8%A7%A3%E5%86%B3Vi%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>yuluo-ding.github.io/2018/06/19/Linux-解决Vi输入中文乱码的问题/</id>
    <published>2018-06-19T07:27:41.000Z</published>
    <updated>2018-06-19T08:00:01.746Z</updated>
    
    <content type="html"><![CDATA[<p>在VPS 中, 有时vi 打开一个文件中, 中文会显示乱码, 用locale 查看如下, </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ locale</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">LANGUAGE=en_US.UTF-8</span><br><span class="line">LC_CTYPE="en_US.UTF-8"</span><br><span class="line">LC_NUMERIC="en_US.UTF-8"</span><br><span class="line">LC_TIME="en_US.UTF-8"</span><br><span class="line">LC_COLLATE="en_US.UTF-8"</span><br><span class="line">LC_MONETARY="en_US.UTF-8"</span><br><span class="line">LC_MESSAGES="en_US.UTF-8"</span><br><span class="line">LC_PAPER="en_US.UTF-8"</span><br><span class="line">LC_NAME="en_US.UTF-8"</span><br><span class="line">LC_ADDRESS="en_US.UTF-8"</span><br><span class="line">LC_TELEPHONE="en_US.UTF-8"</span><br><span class="line">LC_MEASUREMENT="en_US.UTF-8"</span><br><span class="line">LC_IDENTIFICATION="en_US.UTF-8"</span><br><span class="line">LC_ALL=en_US.UTF-8</span><br></pre></td></tr></table></figure><p>其实vi中输入中文乱码与上述系统语言编码无关，是vi自身的环境变量设置出了问题, 解决办法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ vi .viminfo  # ubuntu 18</span><br><span class="line">encoding=latin1#修改成下面</span><br><span class="line">encoding=utf-8</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在VPS 中, 有时vi 打开一个文件中, 中文会显示乱码, 用locale 查看如下, &lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Red Hat Linux卸载旧版本的JDK安装新版本的JDK</title>
    <link href="yuluo-ding.github.io/2018/06/14/Red-Hat-Linux%E5%8D%B8%E8%BD%BD%E6%97%A7%E7%89%88%E6%9C%AC%E7%9A%84JDK%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84JDK/"/>
    <id>yuluo-ding.github.io/2018/06/14/Red-Hat-Linux卸载旧版本的JDK安装新版本的JDK/</id>
    <published>2018-06-14T06:15:37.000Z</published>
    <updated>2018-06-14T06:42:41.434Z</updated>
    
    <content type="html"><![CDATA[<p>做一个安装和记录的流程:</p><ol><li><p>查看内核</p><p><code>uname -a</code>来判断是32 位还是64 位还是其余什么的机器</p></li><li><p>查看java 版本</p><p><code>rpm -qa | grep gcj</code></p></li><li><p>卸载java</p><p><code>yum -y remove javaname</code></p></li><li><p>给新的java 程序分配权限</p><p><code>chmod +x newjavaname</code></p></li><li><p>执行安装程序</p><p><code>./newjavaname</code></p></li><li><p>设置path与classpath</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/newjavaname</span><br><span class="line">export path=$path:$JAVA_HOME/bin;</span><br><span class="line">export path=$path:$JAVA_HOME/jre/bin</span><br><span class="line">export classpath=.:/usr/java/newjavaname/lib:/usr/java/newjavaname/jre/lib:$CLASSPATH</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做一个安装和记录的流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看内核&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uname -a&lt;/code&gt;来判断是32 位还是64 位还是其余什么的机器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看java 版本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rpm -qa | g
      
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>mac OS 设置单个应用语言的方法</title>
    <link href="yuluo-ding.github.io/2018/05/04/mac-OS-%E8%AE%BE%E7%BD%AE%E5%8D%95%E4%B8%AA%E5%BA%94%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>yuluo-ding.github.io/2018/05/04/mac-OS-设置单个应用的方法/</id>
    <published>2018-05-04T06:40:28.000Z</published>
    <updated>2018-05-28T13:44:03.028Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近使用office时候发现了一个问题，由于电脑设置默认语言为英文。office也会自动切换为英文语言。想单独改office为中文版。找了一圈没找到方法，搜索了半天，发现很多人无法解决，要么就是修改电脑默认语言，还好最后在office官网找到了一个答案。</p><p><a href="https://answers.microsoft.com/en-us/msoffice/forum/msoffice_other-mso_mac-mso_mac2016/how-to-manually-change-the-language-used-in-office/abe2a9c1-f550-45de-9d0e-58b99f206c41" target="_blank" rel="noopener">关于office 语言修改</a></p><p>可以使用以下命令修改:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.microsoft.Word AppleLanguages '("zh-cn")'</span><br><span class="line">defaults write com.microsoft.Excel AppleLanguages '("zh-cn")'</span><br><span class="line">defaults write com.microsoft.Powerpoint AppleLanguages '("zh-cn")'</span><br></pre></td></tr></table></figure><p>如上, 其余的应用, 也可以如此设置.</p><p>如果不想要这个语言设置了, 可以使用如下设置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults delete com.apple.AddressBook AppleLanguages</span><br></pre></td></tr></table></figure><p> 其实查询语言的ID 的为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdls -name kMDItemCFBundleIdentifier /Applications/Microsoft\ Word.app</span><br></pre></td></tr></table></figure><p> 结果为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kMDItemCFBundleIdentifier = "com.microsoft.Word"</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    最近使用office时候发现了一个问题，由于电脑设置默认语言为英文。office也会自动切换为英文语言。想单独改office为中文版。找了一圈没找到方法，搜索了半天，发现很多人无法解决，要么就是修改电脑默认语言，还好最后在office官网找到了一个答案。&lt;/p&gt;

      
    
    </summary>
    
      <category term="mac OS" scheme="yuluo-ding.github.io/categories/mac-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>获取小程序的openid与unionid</title>
    <link href="yuluo-ding.github.io/2018/04/16/%E8%8E%B7%E5%8F%96%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84openid%E4%B8%8Eunionid/"/>
    <id>yuluo-ding.github.io/2018/04/16/获取小程序的openid与unionid/</id>
    <published>2018-04-16T01:56:22.000Z</published>
    <updated>2018-05-04T06:38:25.681Z</updated>
    
    <content type="html"><![CDATA[<p>需要发布的小程序基本都要用到openid，这里保存一下自己的代码。<br>一种是不需要服务器的，通过微信提供的接口简单获取openid；一种是有服务器的情况下，获取openid和一些加密的信息，如unionid。</p><h4 id="简单获取openid">简单获取openid</h4><h6 id="这里的简单获取，是指调试的时候可以使用，正常的情况应该是通过服务器来获取">这里的简单获取，是指调试的时候可以使用，正常的情况应该是通过服务器来获取</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> code = res.code; <span class="comment">// 复制给变量就可以打印了，醉了</span></span><br><span class="line">    <span class="keyword">if</span> (res.code) &#123;</span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// userInfo 只存储个人的基础数据</span></span><br><span class="line">          wx.setStorageSync(<span class="string">'userInfo'</span>, res.userInfo);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 只获取openid的话，自己就可以</span></span><br><span class="line">          that.getOpenid(code);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'获取用户登录态失败！'</span> + res.errMsg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自己获取openid和session_key</span></span><br><span class="line">  <span class="comment">// 微信提供的接口，其中appid和secret都是放在globalData中的</span></span><br><span class="line">  getOpenid: <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: <span class="string">'https://api.weixin.qq.com/sns/jscode2session?appid='</span> + that.globalData.appid + <span class="string">'&amp;secret='</span> + that.globalData.secret + <span class="string">'&amp;js_code='</span> + code + <span class="string">'&amp;grant_type=authorization_code'</span>,</span><br><span class="line">      data: &#123;&#125;,</span><br><span class="line">      method: <span class="string">'GET'</span>,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">        obj.openid = res.data.openid;</span><br><span class="line">        obj.expires_in = <span class="built_in">Date</span>.now() + res.data.expires_in;</span><br><span class="line">        obj.session_key = res.data.session_key; </span><br><span class="line">        wx.setStorageSync(<span class="string">'openid'</span>, obj.openid);<span class="comment">// 存储openid  </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h4 id="通过服务器获取openid和unionid">通过服务器获取openid和unionid</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> code = res.code; <span class="comment">// 复制给变量就可以打印了，醉了</span></span><br><span class="line">    <span class="keyword">if</span> (res.code) &#123;</span><br><span class="line">      wx.getUserInfo(&#123;</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// userInfo 只存储个人的基础数据</span></span><br><span class="line">          wx.setStorageSync(<span class="string">'userInfo'</span>, res.userInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求自己的服务器，解密用户信息 获取unionId等加密信息</span></span><br><span class="line">        wx.request(&#123;</span><br><span class="line">          url: url.host + <span class="string">'/decodeUserInfo'</span>,<span class="comment">//自己的服务接口地址</span></span><br><span class="line">          method: <span class="string">'POST'</span>,</span><br><span class="line">          header: &#123;</span><br><span class="line">          <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          data: &#123;</span><br><span class="line">          encryptedData: res.encryptedData,</span><br><span class="line">          iv: res.iv,</span><br><span class="line">          code: code,</span><br><span class="line">          &#125;,</span><br><span class="line">          success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//4.解密成功后 获取自己服务器返回的结果</span></span><br><span class="line">            <span class="keyword">if</span> (data.data.code == <span class="number">200</span>) &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'解密成功'</span>);</span><br><span class="line">              <span class="keyword">var</span> encryptInfo = data.data.data;</span><br><span class="line">                    </span><br><span class="line">              wx.setStorageSync(<span class="string">'openid'</span>, encryptInfo.openId); <span class="comment">// 单独存储openid</span></span><br><span class="line">              wx.setStorageSync(<span class="string">'encryptInfo'</span>, encryptInfo); <span class="comment">// 存储解密之后的数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'解密失败'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        fail: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(res);</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'请求错误'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'获取用户登录态失败！'</span> + res.errMsg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="最后，可以把这个方法给暴露出来，让其他界面调用">最后，可以把这个方法给暴露出来，让其他界面调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给其他界面调用，用来获取用户信息，防止没有获取成功</span></span><br><span class="line">  getUserInfo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> userInfo = wx.getStorageSync(<span class="string">'userInfo'</span>) || &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> openid = wx.getStorageSync(<span class="string">'openid'</span>) || <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!userInfo.nickName || !openid) &#123;</span><br><span class="line">      that.getData();  <span class="comment">// 将wx.login(&#123;&#125;) 方法放入其中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其实获取unionid的方法主要在后台实现，需要根据微信提供的方法去解密，具体的解密文档可以参考以下内容: <a href="https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fqq_27626333%2Farticle%2Fdetails%2F54614037" target="_blank" rel="noopener">微信小程序获取用户openid</a> 与 <a href="https://link.jianshu.com/?t=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F25124713" target="_blank" rel="noopener">微信小程序联盟：微信小程序之获取并解密用户数据（获取openId、unionId）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需要发布的小程序基本都要用到openid，这里保存一下自己的代码。&lt;br&gt;一种是不需要服务器的，通过微信提供的接口简单获取openid；一种是有服务器的情况下，获取openid和一些加密的信息，如unionid。&lt;/p&gt;
&lt;h4 id=&quot;简单获取openid&quot;&gt;简单获取op
      
    
    </summary>
    
      <category term="WeiXin" scheme="yuluo-ding.github.io/categories/WeiXin/"/>
    
    
  </entry>
  
  <entry>
    <title>VPS 安全措施</title>
    <link href="yuluo-ding.github.io/2018/04/15/VPS-%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD/"/>
    <id>yuluo-ding.github.io/2018/04/15/VPS-安全措施/</id>
    <published>2018-04-15T15:39:47.000Z</published>
    <updated>2018-04-15T15:45:11.022Z</updated>
    
    <content type="html"><![CDATA[<p>一个部署在公网的VPS, 面临不断的网络扫描和攻击, 可以参考如下步骤.</p><h5 id="1-_配置SSH安全访问密钥，关闭密码登录">1. 配置SSH安全访问密钥，关闭密码登录</h5><p>a.参考<a href="https://link.jianshu.com/?t=http://edges.blog.51cto.com/705035/581346/" target="_blank" rel="noopener">SecureCRT密钥连接Linux</a>，使用SecureCRT在本机生成公私密钥<br>b.在VPS对应的用户目录下，新建.ssh文件夹，并上传公钥，然后更名为authorized_keys，并修改权限，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.ssh #如果当前用户目录下没有 .ssh 目录，就先创建目录</span><br><span class="line">chmod 700 ~/.ssh</span><br><span class="line">mv id_rsa.pub ~/.ssh</span><br><span class="line">cd .ssh</span><br><span class="line">mv id_rsa.pub authorized_keys</span><br><span class="line">chmod 600 authorized_keys</span><br></pre></td></tr></table></figure><p>c.关闭ssh密码登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">PasswordAuthentication no #此处改为no</span><br></pre></td></tr></table></figure><p>d.【可选】添加普通用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd roubin</span><br><span class="line">passwd roubin</span><br></pre></td></tr></table></figure><p>e.【可选】禁止root登陆</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">PermitRootLogin no  #此处改为no</span><br></pre></td></tr></table></figure><p>f.重启ssh服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><h5 id="2-更改SSH端口及设置">2.更改SSH端口及设置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">Port 22222  #更改默认端口号</span><br><span class="line">MaxAuthTries 5</span><br><span class="line">PermitEmptyPasswords no  #不允许空密码</span><br><span class="line">service sshd reload</span><br><span class="line">iptables -I INPUT -p tcp --dport 22222 -j ACCEPT #CentOS 6 中防火墙开启对应端口</span><br><span class="line">firewall-cmd --zone=public --add-port=22222/tcp --permanent #CentOS 7 中防火墙开启对应端口</span><br></pre></td></tr></table></figure><h5 id="3-锁定口令文件">3.锁定口令文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# chattr +i /etc/passwd</span><br><span class="line">[root@localhost /]# chattr +i /etc/shadow</span><br><span class="line">[root@localhost /]# chattr +i /etc/group</span><br><span class="line">[root@localhost /]# chattr +i /etc/gshadow</span><br></pre></td></tr></table></figure><h5 id="4-安装fail2ban防止暴力破解">4.安装fail2ban防止暴力破解</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apt install -y fail2ban</span><br><span class="line">cp -pf /etc/fail2ban/jail.conf /etc/fail2ban/jail.local</span><br><span class="line">vim /etc/fail2ban/jail.local</span><br><span class="line"></span><br><span class="line"> [sshd]</span><br><span class="line">enabled = trueport = 22222</span><br><span class="line">logpath = %(sshd_log)s</span><br><span class="line">backend = %(sshd_backend)s</span><br><span class="line">filter = sshd</span><br><span class="line">action = iptables[name=SSH, port=22222, protocol=tcp] sendmail-whois[name=SSH, dest=root, sender=fail2ban@example.com]</span><br><span class="line">logpath = /var/log/secure</span><br><span class="line">maxretry = 3</span><br></pre></td></tr></table></figure><h5 id="5-启用iptables">5.启用iptables</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 清除已有iptables规则</span></span><br><span class="line">iptables -F</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许本地回环接口(即运行本机访问本机)</span></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许已建立的或相关连的通行</span></span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">允许所有本机向外的访问</span></span><br><span class="line">iptables -A OUTPUT -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许访问22222(SSH)端口，以下几条相同，分别是22222,80,443端口的访问</span></span><br><span class="line">iptables -A INPUT -p tcp --dport 22222 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">如果有其他端口的话，规则也类似，稍微修改上述语句就行</span></span><br><span class="line"><span class="meta">#</span><span class="bash">允许ping</span></span><br><span class="line">iptables -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT</span><br><span class="line"><span class="meta">#</span><span class="bash">禁止其他未允许的规则访问（注意：如果22端口未加入允许规则，SSH链接会直接断开。）</span></span><br><span class="line">iptables -A INPUT -j REJECT </span><br><span class="line">iptables -A FORWARD -j REJECT</span><br><span class="line"><span class="meta">#</span><span class="bash">保存防火墙规则</span></span><br><span class="line">service iptables save</span><br><span class="line"><span class="meta">#</span><span class="bash">设置防火墙开机启动</span></span><br><span class="line">chkconfig --level 345 iptables on</span><br></pre></td></tr></table></figure><h5 id="6-禁用ipv6">6.禁用ipv6</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编辑/etc/sysconfig/network添加行：</span></span><br><span class="line">NETWORKING_IPV6=no</span><br><span class="line"><span class="meta">#</span><span class="bash">修改/etc/hosts,把ipv6本地主机名解析的注释掉（可选）：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">::1 localhost localhost6 localhost6.localdomain6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">禁止系统加载ipv6相关模块，创建modprobe关于禁用ipv6的设定文件/etc/modprobe.d/disable_ipv6.conf(名字随便起)（RHEL6.0之后没有/etc/modprobe.conf这个文件），内容如下，三选其一（本次使用的第一种）：</span></span><br><span class="line">alias net-pf-10 off</span><br><span class="line">options ipv6 disable=1</span><br><span class="line"><span class="meta">#</span><span class="bash">禁止开机启动</span></span><br><span class="line">chkconfig ip6tables off</span><br><span class="line"><span class="meta">#</span><span class="bash">查看ipv6是否被禁用</span></span><br><span class="line">lsmod | grep -i ipv6</span><br><span class="line">ifconfig | grep -i inet6</span><br></pre></td></tr></table></figure><h5 id="7-阻止百度收录真实位置">7.阻止百度收录真实位置</h5><p>恩，免得上门查水表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line">0.0.0.0 api.map.baidu.com</span><br><span class="line">0.0.0.0 ps.map.baidu.com</span><br><span class="line">0.0.0.0 sv.map.baidu.com</span><br><span class="line">0.0.0.0 offnavi.map.baidu.com</span><br><span class="line">0.0.0.0 newvector.map.baidu.com</span><br><span class="line">0.0.0.0 ulog.imap.baidu.com</span><br><span class="line">0.0.0.0 newloc.map.n.shifen.com</span><br><span class="line"></span><br><span class="line">:: api.map.baidu.com</span><br><span class="line">:: ps.map.baidu.com</span><br><span class="line">:: sv.map.baidu.com</span><br><span class="line">:: offnavi.map.baidu.com</span><br><span class="line">:: newvector.map.baidu.com</span><br><span class="line">:: ulog.imap.baidu.com</span><br><span class="line">:: newloc.map.n.shifen.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个部署在公网的VPS, 面临不断的网络扫描和攻击, 可以参考如下步骤.&lt;/p&gt;
&lt;h5 id=&quot;1-_配置SSH安全访问密钥，关闭密码登录&quot;&gt;1. 配置SSH安全访问密钥，关闭密码登录&lt;/h5&gt;&lt;p&gt;a.参考&lt;a href=&quot;https://link.jianshu.co
      
    
    </summary>
    
      <category term="Linux" scheme="yuluo-ding.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Pyhton 去掉字符串前边的u</title>
    <link href="yuluo-ding.github.io/2018/04/08/Pyhton-%E5%8E%BB%E6%8E%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E8%BE%B9%E7%9A%84u/"/>
    <id>yuluo-ding.github.io/2018/04/08/Pyhton-去掉字符串前边的u/</id>
    <published>2018-04-08T08:32:36.000Z</published>
    <updated>2018-04-16T02:00:35.436Z</updated>
    
    <content type="html"><![CDATA[<p>在用<code>json.load</code>导入json 格式的文件的时候, 打印出来的dict, 会显示的是unicode 编码形式, 下面一种方法可以利用检测编码的形式把<code>u</code>去掉.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(colnames)):</span><br><span class="line">    <span class="keyword">print</span> type(rowData[i])</span><br><span class="line">    <span class="keyword">if</span> type(rowData[i]) == float :<span class="comment">#如果是字符串类型，则进行编码</span></span><br><span class="line">      <span class="keyword">print</span> colnames[i]</span><br><span class="line">      eachRowData[colnames[i].encode(<span class="string">'ascii'</span>)] = rowData[i]</span><br><span class="line">          <span class="comment">#.encode('raw_unicode_escape')</span></span><br><span class="line">    <span class="keyword">elif</span> type(rowData[i]) == unicode:</span><br><span class="line">        eachRowData[colnames[i].encode(<span class="string">'ascii'</span>)] = rowData[i].encode(<span class="string">'ascii'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list.append(eachRowData)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在用&lt;code&gt;json.load&lt;/code&gt;导入json 格式的文件的时候, 打印出来的dict, 会显示的是unicode 编码形式, 下面一种方法可以利用检测编码的形式把&lt;code&gt;u&lt;/code&gt;去掉.&lt;/p&gt;
&lt;figure class=&quot;highlight p
      
    
    </summary>
    
      <category term="Python" scheme="yuluo-ding.github.io/categories/Python/"/>
    
    
  </entry>
  
</feed>
